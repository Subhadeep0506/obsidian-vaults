This series builds upon the [Introduction to Godot](https://docs.godotengine.org/en/stable/getting_started/introduction/index.html#toc-learn-introduction) and will get you started with the editor and the engine. You will learn more about nodes and scenes, code your first classes with GDScript, use signals to make nodes communicate with one another, and more.

The following lessons are here to prepare you for [Your first 2D game](https://docs.godotengine.org/en/stable/getting_started/first_2d_game/index.html#doc-your-first-2d-game), a step-by-step tutorial where you will code a game from scratch. By the end of it, you will have the necessary foundations to explore more features in other sections. We also included links to pages that cover a given topic in-depth where appropriate.

-   [Nodes and Scenes]
-   [Creating instances]
-   [Scripting languages]
-   [Creating your first script]
-   [Listening to player input]
-   [Using signals]

# a. Nodes and Scenes

In [Overview of Godot's key concepts](https://docs.godotengine.org/en/stable/getting_started/introduction/key_concepts_overview.html#doc-key-concepts-overview), we saw that a Godot game is a tree of scenes and that each scene is a tree of nodes. In this lesson, we explain a bit more about them. You will also create your first scene.

## Nodes

**Nodes are the fundamental building blocks of your game**. They are like the ingredients in a recipe. There are dozens of kinds that can display an image, play a sound, represent a camera, and much more.

![../../_images/nodes_and_scenes_nodes.png||170](https://docs.godotengine.org/en/stable/_images/nodes_and_scenes_nodes.png)

All nodes have the following attributes:

-   A name.
-   Editable properties.
-   They receive callbacks to update every frame.
-   You can extend them with new properties and functions.
-   You can add them to another node as a child.

The last attribute is key. **Together, nodes form a tree**, which is a powerful feature to organize projects. Since different nodes have different functions, combining them produces more complex behavior. As we saw before, you can build a playable character the camera follows using a kinematic body node named "Character", a sprite node, a camera node, and a collision shape node.

![../../_images/nodes_and_scenes_character_nodes.png||400](https://docs.godotengine.org/en/stable/_images/nodes_and_scenes_character_nodes.png)

## Scenes

When you organize nodes in a tree, like our character, we call this construct a scene. Once saved, scenes work like new node types in the editor, where you can add them as a child of an existing node. In that case, the instance of the scene appears as a single node with its internals hidden.

Scenes allow you to structure your game's code however you want. You can **compose nodes** to create custom and complex node types, like a game character that runs and jumps, a life bar, a chest with which you can interact, and more.

![../../_images/nodes_and_scenes_3d_scene_example.png||400](https://docs.godotengine.org/en/stable/_images/nodes_and_scenes_3d_scene_example.png)

The Godot editor essentially is a **scene editor**. It has plenty of tools for editing 2D and 3D scenes, as well as user interfaces. A Godot project can contain as many of these scenes as you need. The engine only requires one as your application's **main scene**. This is the scene Godot will first load when you or a player runs the game.

On top of acting like nodes, scenes have the following attributes:

1.  They always have one root node, like the "Character" in our example.
2.  You can save them to your hard drive and load them later.
3.  You can create as many instances of a scene as you'd like. You could have five or ten characters in your game, created from your Character scene.

## Creating your first scene

Let's create our first scene with a single node. To do so, you will need to create a new project first. After opening the project, you should see an empty editor.

![../../_images/nodes_and_scenes_01_empty_editor.png||500](https://docs.godotengine.org/en/stable/_images/nodes_and_scenes_01_empty_editor.png)

In an empty scene, the Scene dock on the left shows several options to add a root node quickly. "2D Scene" adds a Node2D node, "3D Scene" adds a Spatial node, and "User Interface" adds a Control node. These presets are here for convenience; they are not mandatory. "Other Node" lets you select any node to be the root node. In an empty scene, "Other Node" is equivalent to pressing the "Add Child Node" button at the top-left of the Scene dock, which usually adds a new node as a child of the currently selected node.

We're going to add a single Label node to our scene. Its function is to draw text on the screen.

Press the "Add Child Node" button or "Other Node" to create a root node.

![../../_images/nodes_and_scenes_02_scene_dock.png||200](https://docs.godotengine.org/en/stable/_images/nodes_and_scenes_02_scene_dock.png)

The Create Node dialog opens, showing the long list of available nodes.

![../../_images/nodes_and_scenes_03_create_node_window.png||400](https://docs.godotengine.org/en/stable/_images/nodes_and_scenes_03_create_node_window.png)

Select the Label node. You can type its name to filter down the list.

![../../_images/nodes_and_scenes_04_create_label_window.png||450](https://docs.godotengine.org/en/stable/_images/nodes_and_scenes_04_create_label_window.png)

Click on the Label node to select it and click the Create button at the bottom of the window.

![../../_images/nodes_and_scenes_05_editor_with_label.png||500](https://docs.godotengine.org/en/stable/_images/nodes_and_scenes_05_editor_with_label.png)

A lot happens when you add a scene's first node. The scene changes to the 2D workspace because Label is a 2D node type. The Label appears, selected, in the top-left corner of the viewport. The node appears in the Scene dock on the left, and the node's properties appear in the Inspector dock on the right.

## Changing a node's properties

The next step is to change the Label's "Text" property. Let's change it to "Hello World".

Head to the Inspector dock on the right of the viewport. Click inside the field below the Text property and type "Hello World".

![../../_images/nodes_and_scenes_06_label_text.png||200](https://docs.godotengine.org/en/stable/_images/nodes_and_scenes_06_label_text.png)

You will see the text draw in the viewport as you type.

You can move your Label node in the viewport by selecting the move tool in the toolbar.

![../../_images/nodes_and_scenes_07_move_tool.png||200](https://docs.godotengine.org/en/stable/_images/nodes_and_scenes_07_move_tool.png)

With the Label selected, click and drag anywhere in the viewport to move it to the center of the view delimited by the rectangle.

![../../_images/nodes_and_scenes_08_hello_world_text.png||500](https://docs.godotengine.org/en/stable/_images/nodes_and_scenes_08_hello_world_text.png)

## Running the scene

Everything's ready to run the scene! Press the Play Scene button in the top-right of the screen or press F6 (Cmd + R on macOS).

![../../_images/nodes_and_scenes_09_play_scene_button.png||200](https://docs.godotengine.org/en/stable/_images/nodes_and_scenes_09_play_scene_button.png)

A popup invites you to save the scene, which is required to run it.

![../../_images/nodes_and_scenes_10_save_scene_popup.png||300](https://docs.godotengine.org/en/stable/_images/nodes_and_scenes_10_save_scene_popup.png)

Click the Yes button, and in the file browser that appears, press the Save button to save it as "Label.tscn".

![../../_images/nodes_and_scenes_11_save_scene_as.png||500](https://docs.godotengine.org/en/stable/_images/nodes_and_scenes_11_save_scene_as.png)

> [!Note]
> The Save Scene As dialog, like other file dialogs in the editor, only allows you to save files inside the project. The `res://` path at the top of the window represents the project's root directory and stands for "resource path". For more information about file paths in Godot, see [File system](https://docs.godotengine.org/en/stable/tutorials/scripting/filesystem.html#doc-filesystem).

The application should open in a new window and display the text "Hello World".

![../../_images/nodes_and_scenes_12_final_result.png||500](https://docs.godotengine.org/en/stable/_images/nodes_and_scenes_12_final_result.png)

Close the window or press F8 to quit the running scene.

> [!Note]
> If this doesn't immediately work and you have a hiDPI display on at least one of your monitors, go to Project -> Project Settings -> Display -> Window then enable Allow Hidpi under Dpi.

## Setting the main scene

To run our test scene, we used the Play Scene button. Another button next to it allows you to set and run the project's main scene. You can press F5 (Cmd + B on macOS) to do so.

![../../_images/nodes_and_scenes_13_play_button.png||200](https://docs.godotengine.org/en/stable/_images/nodes_and_scenes_13_play_button.png)

A popup window appears and invites you to select the main scene.

![../../_images/nodes_and_scenes_14_main_scene_popup.png||350](https://docs.godotengine.org/en/stable/_images/nodes_and_scenes_14_main_scene_popup.png)

Click the Select button, and in the file dialog that appears, double click on Label.tscn.

![../../_images/nodes_and_scenes_15_select_main_scene.png||500](https://docs.godotengine.org/en/stable/_images/nodes_and_scenes_15_select_main_scene.png)

The demo should run again. Moving forward, every time you run the project, Godot will use this scene as a starting point.

> [!Note]
> The editor saves the main scene's path in a `project.godot` file in your project's directory. While you can edit this text file directly to change project settings, you can also use the "Project -> Project Settings" window to do so.

In the next part, we will discuss another key concept in games and in Godot: creating instances of a scene.

# b. Creating instances

In the previous part, we saw that a scene is a collection of nodes organized in a tree structure, with a single node as its root. You can split your project into any number of scenes. This feature helps you break down and organize your game's different components.

You can create as many scenes as you'd like and save them as files with the `.tscn` extension, which stands for "text scene". The `Label.tscn` file from the previous lesson was an example. We call those files "Packed Scenes" as they pack information about your scene's content.

Here's an example of a ball. It's composed of a [RigidBody2D](https://docs.godotengine.org/en/stable/classes/class_rigidbody2d.html#class-rigidbody2d) node as its root named Ball, which allows the ball to fall and bounce on walls, a [Sprite](https://docs.godotengine.org/en/stable/classes/class_sprite.html#class-sprite) node, and a [CollisionShape2D](https://docs.godotengine.org/en/stable/classes/class_collisionshape2d.html#class-collisionshape2d).

![../../_images/instancing_ball_scene.png||300](https://docs.godotengine.org/en/stable/_images/instancing_ball_scene.png)

Once you saved a scene, it works as a blueprint: you can reproduce it in other scenes as many times as you'd like. Replicating an object from a template like this is called **instancing**.

![../../_images/instancing_ball_instances_example.png||500](https://docs.godotengine.org/en/stable/_images/instancing_ball_instances_example.png)

As we mentioned in the previous part, instanced scenes behave like a node: the editor hides their content by default. When you instance the Ball, you only see the Ball node. Notice also how each duplicate has a unique name.

Every instance of the Ball scene starts with the same structure and properties as `Ball.tscn`. However, you can modify each independently, such as changing how they bounce, how heavy they are, or any property exposed by the source scene.

## In practice

Let's use instancing in practice to see how it works in Godot. We invite you to download the ball's sample project we prepared for you: [`instancing.zip`](https://docs.godotengine.org/en/stable/_downloads/0f77439a03c9c1eb57dab630d028b82d/instancing.zip).

Extract the archive on your computer. Then, open Godot, and in the project manager, click the Import button to import the project.

![../../_images/instancing_import_button.png||500](https://docs.godotengine.org/en/stable/_images/instancing_import_button.png)

In the pop-up that appears, click the browse button and navigate to the folder you extracted.

![../../_images/instancing_import_browse.png||500](https://docs.godotengine.org/en/stable/_images/instancing_import_browse.png)

Double-click the `project.godot` file to open it.

![../../_images/instancing_import_project_file.png||500](https://docs.godotengine.org/en/stable/_images/instancing_import_project_file.png)

Finally, click the Import & Edit button.

![../../_images/instancing_import_and_edit_button.png||500](https://docs.godotengine.org/en/stable/_images/instancing_import_and_edit_button.png)

The project contains two packed scenes: `Main.tscn`, containing walls against which the ball collides, and `Ball.tscn`. The Main scene should open automatically.

![../../_images/instancing_main_scene.png||500](https://docs.godotengine.org/en/stable/_images/instancing_main_scene.png)

Let's add a ball as a child of the Main node. In the Scene dock, select the Main node. Then, click the link icon at the top of the scene dock. This button allows you to add an instance of a scene as a child of the currently selected node.

![../../_images/instancing_scene_link_button.png||200](https://docs.godotengine.org/en/stable/_images/instancing_scene_link_button.png)

Double-click the ball scene to instance it.

![../../_images/instancing_instance_child_window.png||450](https://docs.godotengine.org/en/stable/_images/instancing_instance_child_window.png)

The ball appears in the top-left corner of the viewport.

![../../_images/instancing_ball_instanced.png||500](https://docs.godotengine.org/en/stable/_images/instancing_ball_instanced.png)

Click on it and drag it towards the center of the view.

![../../_images/instancing_ball_moved.png||300](https://docs.godotengine.org/en/stable/_images/instancing_ball_moved.png)

Play the game by pressing F5. You should see it fall.

Now, we want to create more instances of the Ball node. With the ball still selected, press Ctrl-D (Cmd-D on macOS) to call the duplicate command. Click and drag to move the new ball to a different location.

![../../_images/instancing_ball_duplicated.png||300](https://docs.godotengine.org/en/stable/_images/instancing_ball_duplicated.png)

You can repeat this process until you have several in the scene.

![../../_images/instancing_main_scene_with_balls.png||500](https://docs.godotengine.org/en/stable/_images/instancing_main_scene_with_balls.png)

Play the game again. You should now see every ball fall independently from one another. This is what instances do. Each is an independent reproduction of a template scene.

## Editing scenes and instances

There is more to instances. With this feature, you can:

1.  Change the properties of one ball without affecting the others using the Inspector.
2.  Change the default properties of every Ball by opening the `Ball.tscn` scene and making a change to the Ball node there. Upon saving, all instances of the Ball in the project will see their values update.

> [!Note]
> Changing a property on an instance always overrides values from the corresponding packed scene.

Let's try this. Open `Ball.tscn` and select the Ball node. In the Inspector on the right, click on the PhysicsMaterial property to expand it.

![../../_images/instancing_physics_material_expand.png||200](https://docs.godotengine.org/en/stable/_images/instancing_physics_material_expand.png)

Set its Bounce property to `2` by clicking on the number field, typing `2`, and pressing Enter.

![../../_images/instancing_property_bounce_updated.png||260](https://docs.godotengine.org/en/stable/_images/instancing_property_bounce_updated.png)

Play the game by pressing F5 and notice how all balls now bounce a lot more. As the Ball scene is a template for all instances, modifying it and saving causes all instances to update accordingly.

Let's now adjust an individual instance. Head back to the Main scene by clicking on the corresponding tab above the viewport.

![../../_images/instancing_scene_tabs.png||200](https://docs.godotengine.org/en/stable/_images/instancing_scene_tabs.png)

Select one of the instanced Ball nodes and, in the Inspector, set its Gravity Scale value to `10`.

![../../_images/instancing_property_gravity_scale.png||200](https://docs.godotengine.org/en/stable/_images/instancing_property_gravity_scale.png)

A grey "revert" button appears next to the adjusted property.

![../../_images/instancing_property_revert_icon.png||200](https://docs.godotengine.org/en/stable/_images/instancing_property_revert_icon.png)

This icon indicates you are overriding a value from the source packed scene. Even if you modify the property in the original scene, the value override will be preserved in the instance. Clicking the revert icon will restore the property to the value in the saved scene.

Rerun the game and notice how this ball now falls much faster than the others.

> [!Note]
> If you change a value on the `PhysicsMaterial` of one instance, it will affect all the others. This is because `PhysicsMaterial` is a resource, and resources are shared between instances. To make a resource unique for one instance, right-click on it in the Inspector and click Make Unique in the contextual menu.

Resources are another essential building block of Godot games we will cover in a later lesson.

## Scene instances as a design language

Instances and scenes in Godot offer an excellent design language, setting the engine apart from others out there. We designed Godot around this concept from the ground up.

We recommend dismissing architectural code patterns when making games with Godot, such as Model-View-Controller (MVC) or Entity-Relationship diagrams. Instead, you can start by imagining the elements players will see in your game and structure your code around them.

For example, you could break down a shooter game like so:

![../../_images/instancing_diagram_shooter.png||400](https://docs.godotengine.org/en/stable/_images/instancing_diagram_shooter.png)

You can come up with a diagram like this for almost any type of game. Each rectangle represents an entity that's visible in the game from the player's perspective. The arrows tell you which scene owns which.

Once you have a diagram, we recommended creating a scene for each element listed in it to develop your game. You'll use instancing, either by code or directly in the editor, to build your tree of scenes.

Programmers tend to spend a lot of time designing abstract architectures and trying to fit components into it. Designing based on scenes makes development faster and more straightforward, allowing you to focus on the game logic itself. Because most game components map directly to a scene, using a design based on scene instantiation means you need little other architectural code.

Here's the example of a scene diagram for an open-world game with tons of assets and nested elements:

![../../_images/instancing_diagram_open_world.png||400](https://docs.godotengine.org/en/stable/_images/instancing_diagram_open_world.png)

Imagine we started by creating the room. We could make a couple of different room scenes, with unique arrangements of furniture in them. Later, we could make a house scene that uses multiple room instances for the interior. We would create a citadel out of many instanced houses and a large terrain on which we would place the citadel. Each of these would be a scene instancing one or more sub-scenes.

Later, we could create scenes representing guards and add them to the citadel. They would be indirectly added to the overall game world.

With Godot, it's easy to iterate on your game like this, as all you need to do is create and instantiate more scenes. We designed the editor to be accessible to programmers, designers, and artists alike. A typical team development process can involve 2D or 3D artists, level designers, game designers, and animators, all working with the Godot editor.

## Summary

Instancing, the process of producing an object from a blueprint has many handy uses. With scenes, it gives you:

-   The ability to divide your game into reusable components.
-   A tool to structure and encapsulate complex systems.
-   A language to think about your game project's structure in a natural way.

# c. Scripting languages

This lesson will give you an overview of the available scripting languages in Godot. You will learn the pros and cons of each option. In the next part, you will write your first script using GDScript.

**Scripts attach to a node and extend its behavior**. This means that scripts inherit all functions and properties of the node they attach to.

For example, take a game where a Camera2D node follows a ship. The Camera2D node follows its parent by default. Imagine you want the camera to shake when the player takes damage. As this feature is not built into Godot, you would attach a script to the Camera2D node and code the shake.

![../../_images/scripting_camera_shake.gif||300](https://docs.godotengine.org/en/stable/_images/scripting_camera_shake.gif)

## Available scripting languages

Godot offers **five gameplay programming languages**: GDScript, C#, VisualScript, and, via its GDNative technology, C and C++. There are more [community-supported languages](https://docs.godotengine.org/en/stable/tutorials/scripting/gdnative/what_is_gdnative.html#doc-what-is-gdnative-third-party-bindings), but these are the official ones.

You can use multiple languages in a single project. For instance, in a team, you could code gameplay logic in GDScript as it's fast to write, let level designers script quests in the graphical language VisualScript, and use C# or C++ to implement complex algorithms and maximize their performance. Or you can write everything in GDScript or C#. It's your call.

We provide this flexibility to answer the needs of different game projects and developers.

> [!Warning]
> [Godot 4.0 will remove VisualScript from core entirely.](https://godotengine.org/article/godot-4-will-discontinue-visual-scripting) As a result, creating new projects using visual scripting in Godot is not recommended. Future Godot 4.x releases may have VisualScript reimplemented as an extension.
> While Godot 3.x will keep VisualScript supported, we recommend [trying out GDScript](https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/index.html#toc-learn-scripting-gdscript) instead, especially if you intend to migrate your project to Godot 4.

## Which language should I use?

If you're a beginner, we recommend to **start with GDScript**. We made this language specifically for Godot and the needs of game developers. It has a lightweight and straightforward syntax and provides the tightest integration with Godot.

![../../_images/scripting_gdscript.png||500](https://docs.godotengine.org/en/stable/_images/scripting_gdscript.png)

For C#, you will need an external code editor like [VSCode](https://code.visualstudio.com/) or Visual Studio. While C# support is now mature, you will find fewer learning resources for it compared to GDScript. That's why we recommend C# mainly to users who already have experience with the language.

Let's look at each language's features, as well as its pros and cons.

### GDScript

[GDScript](https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_basics.html#doc-gdscript) is an [object-oriented](https://en.wikipedia.org/wiki/Object-oriented_programming) and [imperative](https://en.wikipedia.org/wiki/Imperative_programming) programming language built for Godot. It's made by and for game developers to save you time coding games. Its features include:

-   A simple syntax that leads to short files.
-   Blazing fast compilation and loading times.
-   Tight editor integration, with code completion for nodes, signals, and more information from the scene it's attached to.
-   Built-in vector and transform types, making it efficient for heavy use of linear algebra, a must for games.
-   Supports multiple threads as efficiently as statically typed languages.
-   No [garbage collection](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)), as this feature eventually gets in the way when creating games. The engine counts references and manages the memory for you in most cases by default, but you can also control memory if you need to.
-   [Gradual typing](https://en.wikipedia.org/wiki/Gradual_typing). Variables have dynamic types by default, but you also can use type hints for strong type checks.

GDScript looks like Python as you structure your code blocks using indentations, but it doesn't work the same way in practice. It's inspired by multiple languages, including Squirrel, Lua, and Python.

> [!question]
> **Why don't we use Python or Lua directly?**
> Years ago, Godot used Python, then Lua. Both languages' integration took a lot of work and had severe limitations. For example, threading support was a big challenge with Python.
> Developing a dedicated language doesn't take us more work and we can tailor it to game developers' needs. We're now working on performance optimizations and features that would've been difficult to offer with third-party languages.

### .NET / C#

As Microsoft's [C#](https://en.wikipedia.org/wiki/C_Sharp_(programming_language)) is a favorite amongst game developers, we officially support it. C# is a mature and flexible language with tons of libraries written for it. We could add support for it thanks to a generous donation from Microsoft.

![../../_images/scripting_csharp.png||500](https://docs.godotengine.org/en/stable/_images/scripting_csharp.png)

C# offers a good tradeoff between performance and ease of use, although you should be aware of its garbage collector.

> [!Note]
> You must use the Mono edition of the Godot editor to script in C#. You can download it on the Godot website's [download](https://godotengine.org/download/) page.
> Since Godot uses the [Mono](https://mono-project.com/) .NET runtime, in theory, you can use any third-party .NET library or framework in Godot, as well as any Common Language Infrastructure-compliant programming language, such as F#, Boo, or ClojureCLR. However, C# is the only officially supported .NET option.

> [!Note]
> GDScript code itself doesn't execute as fast as compiled C# or C++. However, most script code calls functions written with fast algorithms in C++ code inside the engine. In many cases, writing gameplay logic in GDScript, C#, or C++ won't have a significant impact on performance.

### VisualScript

[Visual Scripting](https://docs.godotengine.org/en/stable/tutorials/scripting/visual_script/what_is_visual_scripting.html#doc-what-is-visual-script) is a graph-based visual programming language where you connect blocks. It can be a great tool for non-programmers like game designers and artists.

![../../_images/scripting_visualscript.png||500](https://docs.godotengine.org/en/stable/_images/scripting_visualscript.png)

You can use other languages to create custom blocks that are specific to your game, for example, to script AIs, quests, or dialogues. That's where the strength of VisualScript lies.

While it provides all the basic building blocks you need to code complete games, we do not recommend to use VisualScript this way. Programming everything with it is slow compared to using other programming languages.

> [!info]
> For more information, see [Getting started with VisualScript](https://docs.godotengine.org/en/stable/tutorials/scripting/visual_script/getting_started.html#doc-getting-started-visual-script).

### C and C++ via GDNative

GDNative allows you to write game code in C or C++ without needing to recompile or even restart Godot.

![../../_images/scripting_cpp.png||500](https://docs.godotengine.org/en/stable/_images/scripting_cpp.png)

You can use any version of the language or mix compiler brands and versions for the generated shared libraries, thanks to our use of an internal C API Bridge.

GDNative is the best choice for performance. You don't need to use it throughout an entire game, as you can write other parts in GDScript, C#, or VisualScript.

When working with GDNative, the available types, functions, and properties closely resemble Godot's actual C++ API.

## Summary

Scripts are files containing code that you attach to a node to extend its functionality.

Godot supports five official scripting languages, offering you flexibility between performance and ease of use.

You can mix languages, for instance, to implement demanding algorithms with C or C++ and write most of the game logic with GDScript or C#.

# d. Creating your first script

In this lesson, you will code your first script to make the Godot icon turn in circles using GDScript. As we mentioned [in the introduction](https://docs.godotengine.org/en/stable/getting_started/introduction/index.html#toc-learn-introduction), we assume you have programming foundations. The equivalent C# code has been included in another tab for convenience.

![../../_images/scripting_first_script_rotating_godot.gif](https://docs.godotengine.org/en/stable/_images/scripting_first_script_rotating_godot.gif)

> [!info]
> To learn more about GDScript, its keywords, and its syntax, head to the [GDScript reference](https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_basics.html#doc-gdscript).

> [!info]
> To learn more about C#, head to the [C# basics](https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/c_sharp_basics.html#doc-c-sharp) page.

## Project setup

Please create a new project to start with a clean slate. Your project should contain one picture: the Godot icon, which we often use for prototyping in the community.

We need to create a Sprite node to display it in the game. In the Scene dock, click the Other Node button.

![../../_images/scripting_first_script_click_other_node.png](https://docs.godotengine.org/en/stable/_images/scripting_first_script_click_other_node.png)

Type "Sprite" in the search bar to filter nodes and double-click on Sprite to create the node.

![../../_images/scripting_first_script_add_sprite_node.png](https://docs.godotengine.org/en/stable/_images/scripting_first_script_add_sprite_node.png)

Your Scene tab should now only have a Sprite node.

![../../_images/scripting_first_script_scene_tree.png](https://docs.godotengine.org/en/stable/_images/scripting_first_script_scene_tree.png)

A Sprite node needs a texture to display. In the Inspector on the right, you can see that the Texture property says "[empty]". To display the Godot icon, click and drag the file `icon.png` from the FileSystem dock onto the Texture slot.

![../../_images/scripting_first_script_setting_texture.png](https://docs.godotengine.org/en/stable/_images/scripting_first_script_setting_texture.png)

> [!Note]
> You can create Sprite nodes automatically by dragging and dropping images on the viewport.

![../../_images/scripting_first_script_dragging_sprite.png](https://docs.godotengine.org/en/stable/_images/scripting_first_script_dragging_sprite.png)

Then, click and drag the icon in the viewport to center it in the game view.

![../../_images/scripting_first_script_centering_sprite.png](https://docs.godotengine.org/en/stable/_images/scripting_first_script_centering_sprite.png)

## Creating a new script

To create and attach a new script to our node, right-click on Sprite in the scene dock and select "Attach Script".

![../../_images/scripting_first_script_attach_script.png](https://docs.godotengine.org/en/stable/_images/scripting_first_script_attach_script.png)

The Attach Node Script window appears. It allows you to select the script's language and file path, among other options.

Change the Template from Default to Empty to start with a clean file. Leave the other options by default and click the Create button to create the script.

![../../_images/scripting_first_script_attach_node_script.png](https://docs.godotengine.org/en/stable/_images/scripting_first_script_attach_node_script.png)

The Script workspace should appear with your new `Sprite.gd` file open and the following line of code:

```gdscript
extends Sprite
```

Every GDScript file is implicitly a class. The `extends` keyword defines the class this script inherits or extends. In this case, it's `Sprite`, meaning our script will get access to all the properties and functions of the Sprite node, including classes it extends, like `Node2D`, `CanvasItem`, and `Node`.

> [!Note]
> In GDScript, if you omit the line with the `extends` keyword, your class will implicitly extend [Reference](https://docs.godotengine.org/en/stable/classes/class_reference.html#class-reference), which Godot uses to manage your application's memory.
> Inherited properties include the ones you can see in the Inspector dock, like our node's `texture`.

> [!Note]
> By default, the Inspector displays a node's properties in "Title Case", with capitalized words separated by a space. In GDScript code, these properties are in "snake_case", which is lowercase with words separated by an underscore.
> You can hover any property's name in the Inspector to see a description and its identifier in code.

## Hello, world!

Our script currently doesn't do anything. Let's make it print the text "Hello, world!" to the Output bottom panel to get started.

Add the following code to your script:

```gdscript
func _init():
    print("Hello, world!")
```

Let's break it down. The `func` keyword defines a new function named `_init`. This is a special name for our class's constructor. The engine calls `_init()` on every object or node upon creating it in memory, if you define this function.

> [!Note]
> GDScript is an indent-based language. The tab at the start of the line that says `print()` is necessary for the code to work. If you omit it or don't indent a line correctly, the editor will highlight it in red and display the following error message: "Indented block expected".

Save the scene if you haven't already, then press F6 (Cmd + R on macOS) to run it. Look at the **Output** bottom panel that expands. It should display "Hello, world!".

![../../_images/scripting_first_script_print_hello_world.png](https://docs.godotengine.org/en/stable/_images/scripting_first_script_print_hello_world.png)

Delete the `_init()` function, so you're only left with the line `extends Sprite`.

## Turning around

It's time to make our node move and rotate. To do so, we're going to add two member variables to our script: the movement speed in pixels per second and the angular speed in radians per second.

```gdscript
var speed = 400
var angular_speed = PI
```

Member variables sit near the top of the script, after any "extends" lines, but before functions. Every node instance with this script attached to it will have its own copy of the `speed` and `angular_speed` properties.

> [!note]
> Angles in Godot work in radians by default, but you have built-in functions and properties available if you prefer to calculate angles in degrees instead.

To move our icon, we need to update its position and rotation every frame in the game loop. We can use the `_process()` virtual function of the `Node` class. If you define it in any class that extends the Node class, like Sprite, Godot will call the function every frame and pass it an argument named `delta`, the time elapsed since the last frame.

> [!note]
> Games work by rendering many images per second, each called a frame, and they do so in a loop. > We measure the rate at which a game produces images in Frames Per Second (FPS). Most games aim for 60 FPS, although you might find figures like 30 FPS on slower mobile devices or 90 to 240 for virtual reality games.

The engine and game developers do their best to update the game world and render images at a constant time interval, but there are always small variations in frame render times. That's why the engine provides us with this delta time value, making our motion independent of our framerate.

At the bottom of the script, define the function:

```gdscript
func _process(delta):
    rotation += angular_speed * delta
```

The `func` keyword defines a new function. After it, we have to write the function's name and arguments it takes in parentheses. A colon ends the definition, and the indented blocks that follow are the function's content or instructions.

> [!Note]
> Notice how `_process()`, like `_init()`, starts with a leading underscore. By convention, Godot's virtual functions, that is to say, built-in functions you can override to communicate with the engine, start with an underscore.

The line inside the function, `rotation += angular_speed * delta`, increments our sprite's rotation every frame. Here, `rotation` is a property inherited from the class `Node2D`, which `Sprite` extends. It controls the rotation of our node and works with radians.

> [!tip]
> In the code editor, you can ctrl-click on any built-in property or function like `position`, `rotation`, or `_process` to open the corresponding documentation in a new tab.

Run the scene to see the Godot icon turn in-place.

![../../_images/scripting_first_script_godot_turning_in_place.gif](https://docs.godotengine.org/en/stable/_images/scripting_first_script_godot_turning_in_place.gif)

### Moving forward

Let's now make the node move. Add the following two lines to the `_process()` function, ensuring the new lines are indented the same way as the one before them.

```gdscript
var velocity = Vector2.UP.rotated(rotation) * speed
position += velocity * delta
```

```csharp
var velocity = Vector2.Up.Rotated(Rotation) * Speed;
Position += velocity * delta;
```

As we already saw, the `var` keyword defines a new variable. If you put it at the top of the script, it defines a property of the class. Inside a function, it defines a local variable: it only exists within the function's scope.

We define a local variable named `velocity`, a 2D vector representing both a direction and a speed. To make the node move forward, we start from the Vector2 class's constant Vector2.UP, a vector pointing up, and rotate it by calling the `Vector2.rotated()` method. This expression, `Vector2.UP.rotated(rotation)`, is a vector pointing forward relative to our icon. Multiplied by our `speed` property, it gives us a velocity we can use to move the node forward.

We add `velocity * delta` to the node's `position` to move it. The position itself is of type [Vector2](https://docs.godotengine.org/en/stable/classes/class_vector2.html#class-vector2), a built-in type in Godot representing a 2D vector.

Run the scene to see the Godot head run in circles.

![../../_images/scripting_first_script_rotating_godot.gif](https://docs.godotengine.org/en/stable/_images/scripting_first_script_rotating_godot.gif)

> [!note]
> Moving a node like that does not take into account colliding with walls or the floor. In [Your first 2D game](https://docs.godotengine.org/en/stable/getting_started/first_2d_game/index.html#doc-your-first-2d-game), you will learn another approach to moving objects while detecting collisions.

Our node currently moves by itself. In the next part [Listening to player input](https://docs.godotengine.org/en/stable/getting_started/step_by_step/scripting_player_input.html#doc-scripting-player-input), we'll use player input to control it.

## Complete script

Here is the complete `Sprite.gd` file for reference.

```gdscript
extends Sprite

var speed = 400
var angular_speed = PI

func _process(delta):
    rotation += angular_speed * delta
    var velocity = Vector2.UP.rotated(rotation) * speed
    position += velocity * delta
```

```csharp
using Godot;

public class Sprite : Godot.Sprite {
    private int Speed = 400;
    private float AngularSpeed = Mathf.Pi;

    public override void _Process(float delta) {
        Rotation += AngularSpeed * delta;
        var velocity = Vector2.Up.Rotated(Rotation) * Speed;

        Position += velocity * delta;
    }
}
```

# e. Listening to player input

Building upon the previous lesson [Creating your first script](https://docs.godotengine.org/en/stable/getting_started/step_by_step/scripting_first_script.html#doc-scripting-first-script), let's look at another important feature of any game: giving control to the player. To add this, we need to modify our `Sprite.gd` code.

![../../_images/scripting_first_script_moving_with_input.gif](https://docs.godotengine.org/en/stable/_images/scripting_first_script_moving_with_input.gif)

You have two main tools to process the player's input in Godot:

1.  The built-in input callbacks, mainly `_unhandled_input()`. Like `_process()`, it's a built-in virtual function that Godot calls every time the player presses a key. It's the tool you want to use to react to events that don't happen every frame, like pressing Space to jump. To learn more about input callbacks, see [Using InputEvent](https://docs.godotengine.org/en/stable/tutorials/inputs/inputevent.html#doc-inputevent).
    
2.  The `Input` singleton. A singleton is a globally accessible object. Godot provides access to several in scripts. It's the right tool to check for input every frame.
    

We're going to use the `Input` singleton here as we need to know if the player wants to turn or move every frame.

For turning, we should use a new variable: `direction`. In our `_process()` function, replace the `rotation += angular_speed * delta` line with the code below.

```gdscript I'm A tab
var direction = 0
if Input.is_action_pressed("ui_left"):
    direction = -1
if Input.is_action_pressed("ui_right"):
    direction = 1

rotation += angular_speed * direction * delta
```

```c# I'm B tab
var direction = 0;
if (Input.IsActionPressed("ui_left")) {
    direction = -1;
}
if (Input.IsActionPressed("ui_right")) {
    direction = 1;
}

Rotation += AngularSpeed * direction * delta;
```

Our `direction` local variable is a multiplier representing the direction in which the player wants to turn. A value of `0` means the player isn't pressing the left or the right arrow key. A value of `1` means the player wants to turn right, and `-1` means they want to turn left.

To produce these values, we introduce conditions and the use of `Input`. A condition starts with the `if` keyword in GDScript and ends with a colon. The condition is the expression between the keyword and the end of the line.

To check if a key was pressed this frame, we call `Input.is_action_pressed()`. The method takes a text string representing an input action and returns `true` if the action is pressed, `false` otherwise.

The two actions we use above, "ui_left" and "ui_right", are predefined in every Godot project. They respectively trigger when the player presses the left and right arrows on the keyboard or left and right on a gamepad's D-pad.

> [!note]
> You can see and edit input actions in your project by going to Project -> Project Settings and clicking on the Input Map tab.

Finally, we use the `direction` as a multiplier when we update the node's `rotation`: `rotation += angular_speed * direction * delta`.

If you run the scene with this code, the icon should rotate when you press Left and Right.

## Moving when pressing "up"

To only move when pressing a key, we need to modify the code that calculates the velocity. Replace the line starting with `var velocity` with the code below.

```gdscript
var velocity = Vector2.ZERO
if Input.is_action_pressed("ui_up"):
    velocity = Vector2.UP.rotated(rotation) * speed
```

```c#
var velocity = Vector2.Zero;
if (Input.IsActionPressed("ui_up")) {
    velocity = Vector2.Up.Rotated(Rotation) * Speed;
}
```

We initialize the `velocity` with a value of `Vector2.ZERO`, another constant of the built-in `Vector` type representing a 2D vector of length 0.

If the player presses the "ui_up" action, we then update the velocity's value, causing the sprite to move forward.

## Complete script

Here is the complete `Sprite.gd` file for reference.

```gdscript
extends Sprite

var speed = 400
var angular_speed = PI

func _process(delta):
    var direction = 0
    if Input.is_action_pressed("ui_left"):
        direction = -1
    if Input.is_action_pressed("ui_right"):
        direction = 1

    rotation += angular_speed * direction * delta

    var velocity = Vector2.ZERO
    if Input.is_action_pressed("ui_up"):
        velocity = Vector2.UP.rotated(rotation) * speed

    position += velocity * delta
```

```c#
using Godot;

public class Sprite : Godot.Sprite {
    private float Speed = 400;
    private float AngularSpeed = Mathf.Pi;

    public override void _Process(float delta) {
        var direction = 0;
        if (Input.IsActionPressed("ui_left")) {
            direction = -1;
        }
        if (Input.IsActionPressed("ui_right")) {
            direction = 1;
        }

        Rotation += AngularSpeed * direction * delta;

        var velocity = Vector2.Zero;
        if (Input.IsActionPressed("ui_up")) {
            velocity = Vector2.Up.Rotated(Rotation) * Speed;
        }

        Position += velocity * delta;
    }
}
```

If you run the scene, you should now be able to rotate with the left and right arrow keys and move forward by pressing Up.

![../../_images/scripting_first_script_moving_with_input.gif](https://docs.godotengine.org/en/stable/_images/scripting_first_script_moving_with_input.gif)

## Summary

In summary, every script in Godot represents a class and extends one of the engine's built-in classes. The node types your classes inherit from give you access to properties like `rotation` and `position` in our sprite's case. You also inherit many functions, which we didn't get to use in this example.

In GDScript, the variables you put at the top of the file are your class's properties, also called member variables. Besides variables, you can define functions, which, for the most part, will be your classes' methods.

Godot provides several virtual functions you can define to connect your class with the engine. These include `_process()`, to apply changes to the node every frame, and `_unhandled_input()`, to receive input events like key and button presses from the users. There are quite a few more.

The `Input` singleton allows you to react to the players' input anywhere in your code. In particular, you'll get to use it in the `_process()` loop.

In the next lesson [Using signals](https://docs.godotengine.org/en/stable/getting_started/step_by_step/signals.html#doc-signals), we'll build upon the relationship between scripts and nodes by having our nodes trigger code in scripts.

# f. Using signals

In this lesson, we will look at signals. They are messages that nodes emit when something specific happens to them, like a button being pressed. Other nodes can connect to that signal and call a function when the event occurs.

Signals are a delegation mechanism built into Godot that allows one game object to react to a change in another without them referencing one another. Using signals limits [coupling](https://en.wikipedia.org/wiki/Coupling_(computer_programming)) and keeps your code flexible.

For example, you might have a life bar on the screen that represents the player’s health. When the player takes damage or uses a healing potion, you want the bar to reflect the change. To do so, in Godot, you would use signals.

> [!Note]
> As mentioned in the introduction, signals are Godot's version of the observer pattern. You can learn more about it here: [https://gameprogrammingpatterns.com/observer.html](https://gameprogrammingpatterns.com/observer.html)

We will now use a signal to make our Godot icon from the previous lesson ([Listening to player input](https://docs.godotengine.org/en/stable/getting_started/step_by_step/scripting_player_input.html#doc-scripting-player-input)) move and stop by pressing a button.

## Scene setup

To add a button to our game, we will create a new "main" scene which will include both a button and the `Sprite.tscn` scene that we scripted in previous lessons.

Create a new scene by going to the menu Scene -> New Scene.

![../../_images/signals_01_new_scene.png](https://docs.godotengine.org/en/stable/_images/signals_01_new_scene.png)

In the Scene dock, click the 2D Scene button. This will add a Node2D as our root.

![../../_images/signals_02_2d_scene.png](https://docs.godotengine.org/en/stable/_images/signals_02_2d_scene.png)

In the FileSystem dock, click and drag the `Sprite.tscn` file you saved previously onto the Node2D to instantiate it.

![../../_images/signals_03_dragging_scene.png](https://docs.godotengine.org/en/stable/_images/signals_03_dragging_scene.png)

We want to add another node as a sibling of the Sprite. To do so, right-click on Node2D and select Add Child Node.

![../../_images/signals_04_add_child_node.png](https://docs.godotengine.org/en/stable/_images/signals_04_add_child_node.png)

Search for the Button node type and add it.

![../../_images/signals_05_add_button.png](https://docs.godotengine.org/en/stable/_images/signals_05_add_button.png)

The node is small by default. Click and drag on the bottom-right handle of the Button in the viewport to resize it.

![../../_images/signals_06_drag_button.png](https://docs.godotengine.org/en/stable/_images/signals_06_drag_button.png)

If you don't see the handles, ensure the select tool is active in the toolbar.

![../../_images/signals_07_select_tool.png](https://docs.godotengine.org/en/stable/_images/signals_07_select_tool.png)

Click and drag on the button itself to move it closer to the sprite.

You can also write a label on the Button by editing its Text property in the Inspector. Enter "Toggle motion".

![../../_images/signals_08_toggle_motion_text.png](https://docs.godotengine.org/en/stable/_images/signals_08_toggle_motion_text.png)

Your scene tree and viewport should look like this.

![../../_images/signals_09_scene_setup.png](https://docs.godotengine.org/en/stable/_images/signals_09_scene_setup.png)

Save your newly created scene. You can then run it with F6. At the moment, the button will be visible, but nothing will happen if you press it.

## Connecting a signal in the editor

Here, we want to connect the Button's "pressed" signal to our Sprite, and we want to call a new function that will toggle its motion on and off. We need to have a script attached to the Sprite node, which we do from the previous lesson.

You can connect signals in the Node dock. Select the Button node and, on the right side of the editor, click on the tab named "Node" next to the Inspector.

![../../_images/signals_10_node_dock.png](https://docs.godotengine.org/en/stable/_images/signals_10_node_dock.png)

The dock displays a list of signals available on the selected node.

![../../_images/signals_11_pressed_signals.png](https://docs.godotengine.org/en/stable/_images/signals_11_pressed_signals.png)

Double-click the "pressed" signal to open the node connection window.

![../../_images/signals_12_node_connection.png](https://docs.godotengine.org/en/stable/_images/signals_12_node_connection.png)

There, you can connect the signal to the Sprite node. The node needs a receiver method, a function that Godot will call when the Button emits the signal. The editor generates one for you. By convention, we name these callback methods "_on_NodeName_signal_name". Here, it'll be "_on_Button_pressed".

> [!Note]
> When connecting signals via the editor's Node dock, you can use two modes. The simple one only allows you to connect to nodes that have a script attached to them and creates a new callback function on them.

![../../_images/signals_advanced_connection_window.png](https://docs.godotengine.org/en/stable/_images/signals_advanced_connection_window.png)

The advanced view lets you connect to any node and any built-in function, add arguments to the callback, and set options. You can toggle the mode in the window's bottom-right by clicking the Advanced button.

Click the Connect button to complete the signal connection and jump to the Script workspace. You should see the new method with a connection icon in the left margin.

![../../_images/signals_13_signals_connection_icon.png](https://docs.godotengine.org/en/stable/_images/signals_13_signals_connection_icon.png)

If you click the icon, a window pops up and displays information about the connection. This feature is only available when connecting nodes in the editor.

![../../_images/signals_14_signals_connection_info.png](https://docs.godotengine.org/en/stable/_images/signals_14_signals_connection_info.png)

Let's replace the line with the `pass` keyword with code that'll toggle the node's motion.

Our Sprite moves thanks to code in the `_process()` function. Godot provides a method to toggle processing on and off: [Node.set_process()](https://docs.godotengine.org/en/stable/classes/class_node.html#class-node-method-set-process). Another method of the Node class, `is_processing()`, returns `true` if idle processing is active. We can use the `not` keyword to invert the value.

```gdscript
func _on_Button_pressed():
    set_process(not is_processing())
```

This function will toggle processing and, in turn, the icon's motion on and off upon pressing the button.

Before trying the game, we need to simplify our `_process()` function to move the node automatically and not wait for user input. Replace it with the following code, which we saw two lessons ago:

```gdscript
func _process(delta):
    rotation += angular_speed * delta
    var velocity = Vector2.UP.rotated(rotation) * speed
    position += velocity * delta
```

Your complete `Sprite.gd` code should look like the following.

```gdscript
extends Sprite

var speed = 400
var angular_speed = PI

func _process(delta):
    rotation += angular_speed * delta
    var velocity = Vector2.UP.rotated(rotation) * speed
    position += velocity * delta

func _on_Button_pressed():
    set_process(not is_processing())
```

Run the scene now and click the button to see the sprite start and stop.

## Connecting a signal via code

You can connect signals via code instead of using the editor. This is necessary when you create nodes or instantiate scenes inside of a script.

Let's use a different node here. Godot has a [Timer](https://docs.godotengine.org/en/stable/classes/class_timer.html#class-timer) node that's useful to implement skill cooldown times, weapon reloading, and more.

Head back to the 2D workspace. You can either click the "2D" text at the top of the window or press Ctrl + F1 (Alt + 1 on macOS).

In the Scene dock, right-click on the Sprite node and add a new child node. Search for Timer and add the corresponding node. Your scene should now look like this.

![../../_images/signals_15_scene_tree.png](https://docs.godotengine.org/en/stable/_images/signals_15_scene_tree.png)

With the Timer node selected, go to the Inspector and check the **Autostart** property.

![../../_images/signals_18_timer_autostart.png](https://docs.godotengine.org/en/stable/_images/signals_18_timer_autostart.png)

Click the script icon next to Sprite to jump back to the scripting workspace.

![../../_images/signals_16_click_script.png](https://docs.godotengine.org/en/stable/_images/signals_16_click_script.png)

We need to do two operations to connect the nodes via code:

1.  Get a reference to the Timer from the Sprite.
    
2.  Call the Timer's `connect()` method.
    

> [!note]
> To connect to a signal via code, you need to call the `connect()` method of the node you want to listen to. In this case, we want to listen to the Timer's "timeout" signal.

We want to connect the signal when the scene is instantiated, and we can do that using the [`Node._ready()`](https://docs.godotengine.org/en/stable/classes/class_node.html#class-node-method-ready) built-in function, which is called automatically by the engine when a node is fully instantiated.

To get a reference to a node relative to the current one, we use the method [Node.get_node()](https://docs.godotengine.org/en/stable/classes/class_node.html#class-node-method-get-node). We can store the reference in a variable.

```gdscript
func _ready():
    var timer = get_node("Timer")
```

The function `get_node()` looks at the Sprite's children and gets nodes by their name. For example, if you renamed the Timer node to "BlinkingTimer" in the editor, you would have to change the call to `get_node("BlinkingTimer")`.

We can now connect the Timer to the Sprite in the `_ready()` function.

```gdscript
func _ready():
    var timer = get_node("Timer")
    timer.connect("timeout", self, "_on_Timer_timeout")
```

The line reads like so: we connect the Timer's "timeout" signal to the node to which the script is attached (`self`). When the Timer emits "timeout", we want to call the function "`_on_Timer_timeout`", that we need to define. Let's add it at the bottom of our script and use it to toggle our sprite's visibility.

```gdscript
func _on_Timer_timeout():
    visible = not visible
```

The `visible` property is a boolean that controls the visibility of our node. The line `visible = not visible` toggles the value. If `visible` is `true`, it becomes `false`, and vice-versa.

If you run the scene now, you will see that the sprite blinks on and off, at one second intervals.

## Complete script

That's it for our little moving and blinking Godot icon demo! Here is the complete `Sprite.gd` file for reference.

```gdscript
extends Sprite

var speed = 400
var angular_speed = PI

func _ready():
    var timer = get_node("Timer")
    timer.connect("timeout", self, "_on_Timer_timeout")

func _process(delta):
    rotation += angular_speed * delta
    var velocity = Vector2.UP.rotated(rotation) * speed
    position += velocity * delta

func _on_Button_pressed():
    set_process(not is_processing())

func _on_Timer_timeout():
    visible = not visible
```

## Custom signals

> [!note]
> This section is a reference on how to define and use your own signals, and does not build upon the project created in previous lessons.

You can define custom signals in a script. Say, for example, that you want to show a game over screen when the player's health reaches zero. To do so, you could define a signal named "died" or "health_depleted" when their health reaches 0.

```gdscript
extends Node2D

signal health_depleted

var health = 10
```

> [!note]
> As signals represent events that just occurred, we generally use an action verb in the past tense in their names.

Your signals work the same way as built-in ones: they appear in the Node tab and you can connect to them like any other.

![../../_images/signals_17_custom_signal.png](https://docs.godotengine.org/en/stable/_images/signals_17_custom_signal.png)

To emit a signal in your scripts, call `emit_signal()`.

```gdscript
func take_damage(amount):
    health -= amount
    if health <= 0:
        emit_signal("health_depleted")
```

A signal can optionally declare one or more arguments. Specify the argument names between parentheses:

```gdscript
extends Node

signal health_changed(old_value, new_value)
```

> [!note]
> The signal arguments show up in the editor's node dock, and Godot can use them to generate callback functions for you. However, you can still emit any number of arguments when you emit signals. So it's up to you to emit the correct values.

To emit values along with the signal, add them as extra arguments to the `emit_signal()` function:

```gdscript
func take_damage(amount):
    var old_health = health
    health -= amount
    emit_signal("health_changed", old_health, health)
```

## Summary

Any node in Godot emits signals when something specific happens to them, like a button being pressed. Other nodes can connect to individual signals and react to selected events.

Signals have many uses. With them, you can react to a node entering or exiting the game world, to a collision, to a character entering or leaving an area, to an element of the interface changing size, and much more.

For example, an [Area2D](https://docs.godotengine.org/en/stable/classes/class_area2d.html#class-area2d) representing a coin emits a `body_entered` signal whenever the player's physics body enters its collision shape, allowing you to know when the player collected it.

In the next section, [Your first 2D game](https://docs.godotengine.org/en/stable/getting_started/first_2d_game/index.html#doc-your-first-2d-game), you'll create a complete 2D game and put everything you learned so far into practice.
