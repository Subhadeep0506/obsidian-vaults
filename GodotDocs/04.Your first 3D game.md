In this step-by-step tutorial series, you will create your first complete 3D game with Godot. By the end of the series, you will have a simple yet finished project of your own like the animated gif below.

![image0](https://docs.godotengine.org/en/stable/_images/squash-the-creeps-final.gif)

The game we'll code here is similar to [Your first 2D game](https://docs.godotengine.org/en/stable/getting_started/first_2d_game/index.html#doc-your-first-2d-game), with a twist: you can now jump and your goal is to squash the creeps. This way, you will both **recognize patterns** you learned in the previous tutorial and **build upon them** with new code and features.

You will learn to:

-   Work with 3D coordinates with a jumping mechanic.
-   Use kinematic bodies to move 3D characters and detect when and how they collide.
-   Use physics layers and a group to detect interactions with specific entities.
-   Code basic procedural gameplay by instancing monsters at regular time intervals.
-   Design a movement animation and change its speed at run-time.
-   Draw a user interface on a 3D game.
    
And more.

This tutorial is for beginners who followed the complete getting started series. We'll start slow with detailed instructions and shorten them as we do similar steps. If you're an experienced programmer, you can browse the complete demo's source code here: [Squash the Creep source code](https://github.com/GDQuest/godot-3d-dodge-the-creeps/).

> [!Note]
> You can follow this series without having done the 2D one. However, if you're new to game development, we recommend you to start with 2D. 3D game code is always more complex and the 2D series will give you foundations to follow along more comfortably.

We prepared some game assets so we can jump straight to the code. You can download them here: [Squash the Creeps assets](https://github.com/GDQuest/godot-3d-dodge-the-creeps/releases/tag/1.1.0).

We will first work on a basic prototype for the player's movement. We will then add the monsters that we'll spawn randomly around the screen. After that, we'll implement the jump and squashing mechanic before refining the game with some nice animation. We'll wrap up with the score and the retry screen.

## Contents

-   [Setting up the game area]
-   [Player scene and input actions]
-   [Moving the player with code]
-   [Designing the mob scene]
-   [Spawning monsters]
-   [Jumping and squashing monsters]
-   [Killing the player]
-   [Score and replay]
-   [Character animation]
-   [Going further]

# Setting up the game area

In this first part, we're going to set up the game area. Let's get started by importing the start assets and setting up the game scene.

We've prepared a Godot project with the 3D models and sounds we'll use for this tutorial, linked in the index page. If you haven't done so yet, you can download the archive here: [Squash the Creeps assets](https://github.com/GDQuest/godot-3d-dodge-the-creeps/releases/tag/1.0.0).

Once you downloaded it, extract the .zip archive on your computer. Open the Godot project manager and click the _Import_ button.

![image1||400](https://docs.godotengine.org/en/stable/_images/01.import_button.png)

In the import popup, enter the full path to the freshly created directory `squash_the_creeps_start/`. You can click the _Browse_ button on the right to open a file browser and navigate to the `project.godot` file the folder contains.

![image2||400](https://docs.godotengine.org/en/stable/_images/02.browse_to_project_folder.png)

Click _Import & Edit_ to open the project in the editor.

![image3||250](https://docs.godotengine.org/en/stable/_images/03.import_and_edit.png)

The start project contains an icon and two folders: `art/` and `fonts/`. There, you will find the art assets and music we'll use in the game.

![image4||180](https://docs.godotengine.org/en/stable/_images/04.start_assets.png)

There are two 3D models, `player.glb` and `mob.glb`, some materials that belong to these models, and a music track.

## Setting up the playable area

We're going to create our main scene with a plain _Node_ as its root. In the _Scene_ dock, click the _Add Node_ button represented by a "+" icon in the top-left and double-click on _Node_. Name the node "Main". Alternatively, to add a node to the scene, you can press Ctrl + a (or Cmd + a on macOS).

![image5||200](https://docs.godotengine.org/en/stable/_images/05.main_node.png)

Save the scene as `Main.tscn` by pressing Ctrl + s (Cmd + s on macOS).

We'll start by adding a floor that'll prevent the characters from falling. To create static colliders like the floor, walls, or ceilings, you can use _StaticBody_ nodes. They require _CollisionShape_ child nodes to define the collision area. With the _Main_ node selected, add a _StaticBody_ node, then a _CollisionShape_. Rename the _StaticBody_ as _Ground_.

![image6||200](https://docs.godotengine.org/en/stable/_images/06.staticbody_node.png)

A warning sign next to the _CollisionShape_ appears because we haven't defined its shape. If you click the icon, a popup appears to give you more information.

![image7||370](https://docs.godotengine.org/en/stable/_images/07.collision_shape_warning.png)

To create a shape, with the _CollisionShape_ selected, head to the _Inspector_ and click the _[empty]_ field next to the _Shape_ property. Create a new _Box Shape_.

![image8||180](https://docs.godotengine.org/en/stable/_images/08.create_box_shape.png)

The box shape is perfect for flat ground and walls. Its thickness makes it reliable to block even fast-moving objects.

A box's wireframe appears in the viewport with three orange dots. You can click and drag these to edit the shape's extents interactively. We can also precisely set the size in the inspector. Click on the _BoxShape_ to expand the resource. Set its _Extents_ to `30` on the X axis, `1` for the Y axis, and `30` for the Z axis.

![image9||200](https://docs.godotengine.org/en/stable/_images/09.box_extents.png)

> [!Note]
> In 3D, translation and size units are in meters. The box's total size is twice its extents: `60` by `60` meters on the ground plane and `2` units tall. The ground plane is defined by the X and Z axes, while the Y axis represents the height.

Collision shapes are invisible. We need to add a visual floor that goes along with it. Select the _Ground_ node and add a _MeshInstance_ as its child.

![image10||200](https://docs.godotengine.org/en/stable/_images/10.mesh_instance.png)

In the _Inspector_, click on the field next to _Mesh_ and create a _CubeMesh_ resource to create a visible cube.

![image11||200](https://docs.godotengine.org/en/stable/_images/11.cube_mesh.png)

Once again, it's too small by default. Click the cube icon to expand the resource and set its _Size_ to `60`, `2`, and `60`. As the cube resource works with a size rather than extents, we need to use these values so it matches our collision shape.

![image12||180](https://docs.godotengine.org/en/stable/_images/12.cube_resized.png)

You should see a wide grey slab that covers the grid and blue and red axes in the viewport.

We're going to move the ground down so we can see the floor grid. Select the _Ground_ node, hold the Ctrl key down to turn on grid snapping (Cmd on macOS), and click and drag down on the Y axis. It's the green arrow in the move gizmo.

![image13||300](https://docs.godotengine.org/en/stable/_images/13.move_gizmo_y_axis.png)

> [!Note]
> If you can't see the 3D object manipulator like on the image above, ensure the _Select Mode_ is active in the toolbar above the view.

![image14](https://docs.godotengine.org/en/stable/_images/14.select_mode_icon.png)

Move the ground down `1` meter. A label in the bottom-left corner of the viewport tells you how much you're translating the node.

![image15](https://docs.godotengine.org/en/stable/_images/15.translation_amount.png)

> [!Note]
> Moving the _Ground_ node down moves both children along with it. Ensure you move the _Ground_ node, **not** the _MeshInstance_ or the _CollisionShape_.

Let's add a directional light so our scene isn't all grey. Select the _Main_ node and add a _DirectionalLight_ as a child of it. We need to move it and rotate it. Move it up by clicking and dragging on the manipulator's green arrow and click and drag on the red arc to rotate it around the X axis, until the ground is lit.

In the _Inspector_, turn on _Shadow -> Enabled_ by clicking the checkbox.

![image16||200](https://docs.godotengine.org/en/stable/_images/16.turn_on_shadows.png)

At this point, your project should look like this.

![image17||500](https://docs.godotengine.org/en/stable/_images/17.project_with_light.png)

That's our starting point. In the next part, we will work on the player scene and base movement.

# Player scene and input actions

In the next two lessons, we will design the player scene, register custom input actions, and code player movement. By the end, you'll have a playable character that moves in eight directions.

Create a new scene by going to the Scene menu in the top-left and clicking _New Scene_. Create a _KinematicBody_ node as the root and name it _Player_.

![image0||280](https://docs.godotengine.org/en/stable/_images/01.new_scene.png)

Kinematic bodies are complementary to the area and rigid bodies used in the 2D game tutorial. Like rigid bodies, they can move and collide with the environment, but instead of being controlled by the physics engine, you dictate their movement. You will see how we use the node's unique features when we code the jump and squash mechanics.

> [!info]
> To learn more about the different physics node types, see the [Physics introduction](https://docs.godotengine.org/en/stable/tutorials/physics/physics_introduction.html#doc-physics-introduction).

For now, we're going to create a basic rig for our character's 3D model. This will allow us to rotate the model later via code while it plays an animation.

Add a _Spatial_ node as a child of _Player_ and name it _Pivot_. Then, in the FileSystem dock, expand the `art/` folder by double-clicking it and drag and drop `player.glb` onto the _Pivot_ node.

![image1||200](https://docs.godotengine.org/en/stable/_images/02.instantiating_the_model.png)

This should instantiate the model as a child of _Pivot_. You can rename it to _Character_.

![image2||200](https://docs.godotengine.org/en/stable/_images/03.scene_structure.png)

> [!Note]
> The `.glb` files contain 3D scene data based on the open-source GLTF 2.0 specification. They're a modern and powerful alternative to a proprietary format like FBX, which Godot also supports. To produce these files, we designed the model in [Blender 3D](https://www.blender.org/) and exported it to GLTF.

As with all kinds of physics nodes, we need a collision shape for our character to collide with the environment. Select the _Player_ node again and add a _CollisionShape_. In the _Inspector_, assign a _SphereShape_ to the _Shape_ property. The sphere's wireframe appears below the character.

![image3||300](https://docs.godotengine.org/en/stable/_images/04.sphere_shape.png)

It will be the shape the physics engine uses to collide with the environment, so we want it to better fit the 3D model. Shrink it a bit by dragging the orange dot in the viewport. My sphere has a radius of about `0.8` meters.

Then, move the shape up so its bottom roughly aligns with the grid's plane.

![image4||300](https://docs.godotengine.org/en/stable/_images/05.moving_the_sphere_up.png)

You can toggle the model's visibility by clicking the eye icon next to the _Character_ or the _Pivot_ nodes.

![image5||200](https://docs.godotengine.org/en/stable/_images/06.toggling_visibility.png)

Save the scene as `Player.tscn`.

With the nodes ready, we can almost get coding. But first, we need to define some input actions.

## Creating input actions

To move the character, we will listen to the player's input, like pressing the arrow keys. In Godot, while we could write all the key bindings in code, there's a powerful system that allows you to assign a label to a set of keys and buttons. This simplifies our scripts and makes them more readable.

This system is the Input Map. To access its editor, head to the _Project_ menu and select _Project Settings…_.

![image6||270](https://docs.godotengine.org/en/stable/_images/07.project_settings.png)

At the top, there are multiple tabs. Click on _Input Map_. This window allows you to add new actions at the top; they are your labels. In the bottom part, you can bind keys to these actions.

![image7||470](https://docs.godotengine.org/en/stable/_images/07.input_map_tab.png)

Godot projects come with some predefined actions designed for user interface design, which we could use here. But we're defining our own to support gamepads.

We're going to name our actions `move_left`, `move_right`, `move_forward`, `move_back`, and `jump`.

To add an action, write its name in the bar at the top and press Enter.

![image8||500](https://docs.godotengine.org/en/stable/_images/07.adding_action.png)

Create the five actions. Your window should have them all listed at the bottom.

![image9||400](https://docs.godotengine.org/en/stable/_images/08.actions_list_empty.png)

To bind a key or button to an action, click the "+" button to its right. Do this for `move_left` and in the drop-down menu, click _Key_.

![image10](https://docs.godotengine.org/en/stable/_images/08.create_key_action.png)

This option allows you to add a keyboard input. A popup appears and waits for you to press a key. Press the left arrow key and click _OK_.

![image11||200](https://docs.godotengine.org/en/stable/_images/09.keyboard_key_popup.png)

Do the same for the A key.

![image12](https://docs.godotengine.org/en/stable/_images/09.keyboard_keys.png)

Let's now add support for a gamepad's left joystick. Click the "+" button again but this time, select _Joy Axis_.

![image13](https://docs.godotengine.org/en/stable/_images/10.joy_axis_option.png)

The popup gives you two drop-down menus. On the left, you can select a gamepad by index. _Device 0_ corresponds to the first plugged gamepad, _Device 1_ corresponds to the second, and so on. You can select the joystick and direction you want to bind to the input action on the right. Leave the default values and press the _Add_ button.

![image14||300](https://docs.godotengine.org/en/stable/_images/11.joy_axis_popup.png)

Do the same for the other input actions. For example, bind the right arrow, D, and the left joystick's right axis to `move_right`. After binding all keys, your interface should look like this.

![image15||400](https://docs.godotengine.org/en/stable/_images/12.move_inputs_mapped.png)

We have the `jump` action left to set up. Bind the Space key and the gamepad's A button. To bind a gamepad's button, select the _Joy Button_ option in the menu.

![image16](https://docs.godotengine.org/en/stable/_images/13.joy_button_option.png)

Leave the default values and click the _Add_ button.

![image17||300](https://docs.godotengine.org/en/stable/_images/14.add_jump_button.png)

Your jump input action should look like this.

![image18](https://docs.godotengine.org/en/stable/_images/14.jump_input_action.png)

That's all the actions we need for this game. You can use this menu to label any groups of keys and buttons in your projects.

In the next part, we'll code and test the player's movement.

# Moving the player with code

It's time to code! We're going to use the input actions we created in the last part to move the character.

Right-click the _Player_ node and select _Attach Script_ to add a new script to it. In the popup, set the _Template_ to _Empty_ before pressing the _Create_ button.

![image0||270](https://docs.godotengine.org/en/stable/_images/01.attach_script_to_player.png)

Let's start with the class's properties. We're going to define a movement speed, a fall acceleration representing gravity, and a velocity we'll use to move the character.

```gdscript
extends KinematicBody

# How fast the player moves in meters per second.
export var speed = 14
# The downward acceleration when in the air, in meters per second squared.
export var fall_acceleration = 75

var velocity = Vector3.ZERO
```

These are common properties for a moving body. The `velocity` is a 3D vector combining a speed with a direction. Here, we define it as a property because we want to update and reuse its value across frames.

> [!Note]
> The values are quite different from 2D code because distances are in meters. While in 2D, a thousand units (pixels) may only correspond to half of your screen's width, in 3D, it's a kilometer.

Let's code the movement now. We start by calculating the input direction vector using the global `Input` object, in `_physics_process()`.

```gdscript
func _physics_process(delta):
    # We create a local variable to store the input direction.
    var direction = Vector3.ZERO

    # We check for each move input and update the direction accordingly.
    if Input.is_action_pressed("move_right"):
        direction.x += 1
    if Input.is_action_pressed("move_left"):
        direction.x -= 1
    if Input.is_action_pressed("move_back"):
        # Notice how we are working with the vector's x and z axes.
        # In 3D, the XZ plane is the ground plane.
        direction.z += 1
    if Input.is_action_pressed("move_forward"):
        direction.z -= 1
```

Here, we're going to make all calculations using the `_physics_process()` virtual function. Like `_process()`, it allows you to update the node every frame, but it's designed specifically for physics-related code like moving a kinematic or rigid body.

> [!info]
> To learn more about the difference between `_process()` and `_physics_process()`, see [Idle and Physics Processing](https://docs.godotengine.org/en/stable/tutorials/scripting/idle_and_physics_processing.html#doc-idle-and-physics-processing).

We start by initializing a `direction` variable to `Vector3.ZERO`. Then, we check if the player is pressing one or more of the `move_*` inputs and update the vector's `x` and `z` components accordingly. These correspond to the ground plane's axes.

These four conditions give us eight possibilities and eight possible directions.

In case the player presses, say, both W and D simultaneously, the vector will have a length of about `1.4`. But if they press a single key, it will have a length of `1`. We want the vector's length to be consistent. To do so, we can call its `normalize()` method.

```gdscript
#func _physics_process(delta):
    #...

    if direction != Vector3.ZERO:
        direction = direction.normalized()
        $Pivot.look_at(translation + direction, Vector3.UP)
```

Here, we only normalize the vector if the direction has a length greater than zero, which means the player is pressing a direction key.

In this case, we also get the _Pivot_ node and call its `look_at()` method. This method takes a position in space to look at in global coordinates and the up direction. In this case, we can use the `Vector3.UP` constant.

> [!Note]
> A node's local coordinates, like `translation`, are relative to their parent. Global coordinates are relative to the world's main axes you can see in the viewport instead.

In 3D, the property that contains a node's position is `translation`. By adding the `direction` to it, we get a position to look at that's one meter away from the _Player_.

Then, we update the velocity. We have to calculate the ground velocity and the fall speed separately. Be sure to go back one tab so the lines are inside the `_physics_process()` function but outside the condition we just wrote.

```gdscript
func _physics_process(delta):
    #...
    if direction != Vector3.ZERO:
        #...

    # Ground velocity
    velocity.x = direction.x * speed
    velocity.z = direction.z * speed
    # Vertical velocity
    velocity.y -= fall_acceleration * delta
    # Moving the character
    velocity = move_and_slide(velocity, Vector3.UP)
```

For the vertical velocity, we subtract the fall acceleration multiplied by the delta time every frame. Notice the use of the `-=` operator, which is a shorthand for `variable = variable - ...`.

This line of code will cause our character to fall in every frame. This may seem strange if it's already on the floor. But we have to do this for the character to collide with the ground every frame.

The physics engine can only detect interactions with walls, the floor, or other bodies during a given frame if movement and collisions happen. We will use this property later to code the jump.

On the last line, we call `KinematicBody.move_and_slide()`. It's a powerful method of the `KinematicBody` class that allows you to move a character smoothly. If it hits a wall midway through a motion, the engine will try to smooth it out for you.

The function takes two parameters: our velocity and the up direction. It moves the character and returns a leftover velocity after applying collisions. When hitting the floor or a wall, the function will reduce or reset the speed in that direction from you. In our case, storing the function's returned value prevents the character from accumulating vertical momentum, which could otherwise get so big the character would move through the ground slab after a while.

And that's all the code you need to move the character on the floor.

Here is the complete `Player.gd` code for reference.

```
extends KinematicBody

# How fast the player moves in meters per second.
export var speed = 14
# The downward acceleration when in the air, in meters per second squared.
export var fall_acceleration = 75

var velocity = Vector3.ZERO

func _physics_process(delta):
    var direction = Vector3.ZERO

    if Input.is_action_pressed("move_right"):
        direction.x += 1
    if Input.is_action_pressed("move_left"):
        direction.x -= 1
    if Input.is_action_pressed("move_back"):
        direction.z += 1
    if Input.is_action_pressed("move_forward"):
        direction.z -= 1

    if direction != Vector3.ZERO:
        direction = direction.normalized()
        $Pivot.look_at(translation + direction, Vector3.UP)

    velocity.x = direction.x * speed
    velocity.z = direction.z * speed
    velocity.y -= fall_acceleration * delta
    velocity = move_and_slide(velocity, Vector3.UP)
```

## Testing our player's movement

We're going to put our player in the _Main_ scene to test it. To do so, we need to instantiate the player and then add a camera. Unlike in 2D, in 3D, you won't see anything if your viewport doesn't have a camera pointing at something.

Save your _Player_ scene and open the _Main_ scene. You can click on the _Main_ tab at the top of the editor to do so.

![image1||300](https://docs.godotengine.org/en/stable/_images/02.clicking_main_tab.png)

If you closed the scene before, head to the _FileSystem_ dock and double-click `Main.tscn` to re-open it.

To instantiate the _Player_, right-click on the _Main_ node and select _Instance Child Scene_.

![image2||250](https://docs.godotengine.org/en/stable/_images/03.instance_child_scene.png)

In the popup, double-click _Player.tscn_. The character should appear in the center of the viewport.

### Adding a camera

Let's add the camera next. Like we did with our _Player_'s _Pivot_, we're going to create a basic rig. Right-click on the _Main_ node again and select _Add Child Node_ this time. Create a new _Position3D_, name it _CameraPivot_, and add a _Camera_ node as a child of it. Your scene tree should look like this.

![image3||150](https://docs.godotengine.org/en/stable/_images/04.scene_tree_with_camera.png)

Notice the _Preview_ checkbox that appears in the top-left when you have the _Camera_ selected. You can click it to preview the in-game camera projection.

![image4](https://docs.godotengine.org/en/stable/_images/05.camera_preview_checkbox.png)

We're going to use the _Pivot_ to rotate the camera as if it was on a crane. Let's first split the 3D view to be able to freely navigate the scene and see what the camera sees.

In the toolbar right above the viewport, click on _View_, then _2 Viewports_. You can also press Ctrl + 2 (Cmd + 2 on macOS).

![image5||300](https://docs.godotengine.org/en/stable/_images/06.two_viewports.png)

On the bottom view, select the _Camera_ and turn on camera preview by clicking the checkbox.

![image6](https://docs.godotengine.org/en/stable/_images/07.camera_preview_checkbox.png)

In the top view, move the camera about `19` units on the Z axis (the blue one).

![image7||300](https://docs.godotengine.org/en/stable/_images/08.camera_moved.png)

Here's where the magic happens. Select the _CameraPivot_ and rotate it `-45` degrees around the X axis (using the red circle). You'll see the camera move as if it was attached to a crane.

![image8||300](https://docs.godotengine.org/en/stable/_images/09.camera_rotated.png)

You can run the scene by pressing F6 and press the arrow keys to move the character.

![image9||400](https://docs.godotengine.org/en/stable/_images/10.camera_perspective.png)

We can see some empty space around the character due to the perspective projection. In this game, we're going to use an orthographic projection instead to better frame the gameplay area and make it easier for the player to read distances.

Select the _Camera_ again and in the _Inspector_, set the _Projection_ to _Orthogonal_ and the _Size_ to `19`. The character should now look flatter and the ground should fill the background.

![image10||400](https://docs.godotengine.org/en/stable/_images/11.camera_orthographic.png)

With that, we have both player movement and the view in place. Next, we will work on the monsters.

# Designing the mob scene

In this part, you're going to code the monsters, which we'll call mobs. In the next lesson, we'll spawn them randomly around the playable area.

Let's design the monsters themselves in a new scene. The node structure is going to be similar to the _Player_ scene.

Create a scene with, once again, a _KinematicBody_ node as its root. Name it _Mob_. Add a _Spatial_ node as a child of it, name it _Pivot_. And drag and drop the file `mob.glb` from the _FileSystem_ dock onto the _Pivot_ to add the monster's 3D model to the scene. You can rename the newly created _mob_ node into _Character_.

![image0||200](https://docs.godotengine.org/en/stable/_images/01.initial_three_nodes.png)

We need a collision shape for our body to work. Right-click on the _Mob_ node, the scene's root, and click _Add Child Node_.

![image1||270](https://docs.godotengine.org/en/stable/_images/02.add_child_node.png)

Add a _CollisionShape_.

![image2||200](https://docs.godotengine.org/en/stable/_images/03.scene_with_collision_shape.png)

In the _Inspector_, assign a _BoxShape_ to the _Shape_ property.

![image3||200](https://docs.godotengine.org/en/stable/_images/04.create_box_shape.png)

We should change its size to fit the 3D model better. You can do so interactively by clicking and dragging on the orange dots.

The box should touch the floor and be a little thinner than the model. Physics engines work in such a way that if the player's sphere touches even the box's corner, a collision will occur. If the box is a little too big compared to the 3D model, you may die at a distance from the monster, and the game will feel unfair to the players.

![image4||400](https://docs.godotengine.org/en/stable/_images/05.box_final_size.png)

Notice that my box is taller than the monster. It is okay in this game because we're looking at the scene from above and using a fixed perspective. Collision shapes don't have to match the model exactly. It's the way the game feels when you test it that should dictate their form and size.

## Removing monsters off-screen

We're going to spawn monsters at regular time intervals in the game level. If we're not careful, their count could increase to infinity, and we don't want that. Each mob instance has both a memory and a processing cost, and we don't want to pay for it when the mob's outside the screen.

Once a monster leaves the screen, we don't need it anymore, so we can delete it. Godot has a node that detects when objects leave the screen, _VisibilityNotifier_, and we're going to use it to destroy our mobs.

> [!Note]
> When you keep instancing an object in games, there's a technique you can use to avoid the cost of creating and destroying instances all the time called pooling. It consists of pre-creating an array of objects and reusing them over and over.

When working with GDScript, you don't need to worry about this. The main reason to use pools is to avoid freezes with garbage-collected languages like C# or Lua. GDScript uses a different technique to manage memory, reference counting, which doesn't have that caveat. You can learn more about that here [Memory management](https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_basics.html#doc-gdscript-basics-memory-management).

Select the _Mob_ node and add a _VisibilityNotifier_ as a child of it. Another box, pink this time, appears. When this box completely leaves the screen, the node will emit a signal.

![image5||400](https://docs.godotengine.org/en/stable/_images/06.visibility_notifier.png)

Resize it using the orange dots until it covers the entire 3D model.

![image6||300](https://docs.godotengine.org/en/stable/_images/07.visibility_notifier_bbox_resized.png)

### Coding the mob's movement

Let's implement the monster's motion. We're going to do this in two steps. First, we'll write a script on the _Mob_ that defines a function to initialize the monster. We'll then code the randomized spawn mechanism in the _Main_ scene and call the function from there.

Attach a script to the _Mob_.

![image7||270](https://docs.godotengine.org/en/stable/_images/08.mob_attach_script.png)

Here's the movement code to start with. We define two properties, `min_speed` and `max_speed`, to define a random speed range. We then define and initialize the `velocity`.

```gdscript
extends KinematicBody

# Minimum speed of the mob in meters per second.
export var min_speed = 10
# Maximum speed of the mob in meters per second.
export var max_speed = 18

var velocity = Vector3.ZERO

func _physics_process(_delta):
    move_and_slide(velocity)
```

Similarly to the player, we move the mob every frame by calling `KinematicBody`'s `move_and_slide()` method. This time, we don't update the `velocity` every frame: we want the monster to move at a constant speed and leave the screen, even if it were to hit an obstacle.

You may see a warning in GDScript that the return value from `move_and_slide()` is unused. This is expected. You can simply ignore the warning or, if you want to hide it entirely, add the comment `# warning-ignore:return_value_discarded` just above the `move_and_slide(velocity)` line. To read more about the GDScript warning system, see [GDScript warning system](https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/warning_system.html#doc-gdscript-warning-system).

We need to define another function to calculate the start velocity. This function will turn the monster towards the player and randomize both its angle of motion and its velocity.

The function will take a `start_position`, the mob's spawn position, and the `player_position` as its arguments.

We position the mob at `start_position` and turn it towards the player using the `look_at_from_position()` method, and randomize the angle by rotating a random amount around the Y axis. Below, `rand_range()` outputs a random value between `-PI / 4` radians and `PI / 4` radians.

```gdscript
# We will call this function from the Main scene.
func initialize(start_position, player_position):
    # We position the mob and turn it so that it looks at the player.
    look_at_from_position(start_position, player_position, Vector3.UP)
    # And rotate it randomly so it doesn't move exactly toward the player.
    rotate_y(rand_range(-PI / 4, PI / 4))
```

We then calculate a random speed using `rand_range()` once again and we use it to calculate the velocity.

We start by creating a 3D vector pointing forward, multiply it by our `random_speed`, and finally rotate it using the `Vector3` class's `rotated()` method.

```gdscript
func initialize(start_position, player_position):
    # ...

    # We calculate a random speed.
    var random_speed = rand_range(min_speed, max_speed)
    # We calculate a forward velocity that represents the speed.
    velocity = Vector3.FORWARD * random_speed
    # We then rotate the vector based on the mob's Y rotation to move in the direction it's looking.
    velocity = velocity.rotated(Vector3.UP, rotation.y)
```

### Leaving the screen

We still have to destroy the mobs when they leave the screen. To do so, we'll connect our _VisibilityNotifier_ node's `screen_exited` signal to the _Mob_.

Head back to the 3D viewport by clicking on the _3D_ label at the top of the editor. You can also press Ctrl + F2 (Alt + 2 on macOS).

![image8||200](https://docs.godotengine.org/en/stable/_images/09.switch_to_3d_workspace.png)

Select the _VisibilityNotifier_ node and on the right side of the interface, navigate to the _Node_ dock. Double-click the _screen_exited()_ signal.

![image9||170](https://docs.godotengine.org/en/stable/_images/10.node_dock.png)

Connect the signal to the _Mob_.

![image10||300](https://docs.godotengine.org/en/stable/_images/11.connect_signal.png)

This will take you back to the script editor and add a new function for you, `_on_VisibilityNotifier_screen_exited()`. From it, call the `queue_free()` method. This will destroy the mob instance when the _VisibilityNotifier_ 's box leaves the screen.

```gdscript
func _on_VisibilityNotifier_screen_exited():
    queue_free()
```

Our monster is ready to enter the game! In the next part, you will spawn monsters in the game level.

Here is the complete `Mob.gd` script for reference.

```gdscript
extends KinematicBody

# Minimum speed of the mob in meters per second.
export var min_speed = 10
# Maximum speed of the mob in meters per second.
export var max_speed = 18

var velocity = Vector3.ZERO

func _physics_process(_delta):
    move_and_slide(velocity)

func initialize(start_position, player_position):
    look_at_from_position(start_position, player_position, Vector3.UP)
    rotate_y(rand_range(-PI / 4, PI / 4))

    var random_speed = rand_range(min_speed, max_speed)
    velocity = Vector3.FORWARD * random_speed
    velocity = velocity.rotated(Vector3.UP, rotation.y)

func _on_VisibilityNotifier_screen_exited():
    queue_free()
```

# Spawning monsters

In this part, we're going to spawn monsters along a path randomly. By the end, you will have monsters roaming the game board.

![image0||300](https://docs.godotengine.org/en/stable/_images/01.monsters_path_preview.png)

Double-click on `Main.tscn` in the _FileSystem_ dock to open the _Main_ scene.

Before drawing the path, we're going to change the game resolution. Our game has a default window size of `1024x600`. We're going to set it to `720x540`, a nice little box.

Go to _Project -> Project Settings_.

![image1||300](https://docs.godotengine.org/en/stable/_images/02.project_settings.png)

In the left menu, navigate down to _Display -> Window_. On the right, set the _Width_ to `720` and the _Height_ to `540`.

![image2||400](https://docs.godotengine.org/en/stable/_images/03.window_settings.png)

## Creating the spawn path

Like you did in the 2D game tutorial, you're going to design a path and use a _PathFollow_ node to sample random locations on it.

In 3D though, it's a bit more complicated to draw the path. We want it to be around the game view so monsters appear right outside the screen. But if we draw a path, we won't see it from the camera preview.

To find the view's limits, we can use some placeholder meshes. Your viewport should still be split into two parts, with the camera preview at the bottom. If that isn't the case, press Ctrl + 2 (Cmd + 2 on macOS) to split the view into two. Select the _Camera_ node and click the _Preview_ checkbox in the bottom viewport.

![image3||500](https://docs.godotengine.org/en/stable/_images/04.camera_preview.png)

### Adding placeholder cylinders

Let's add the placeholder meshes. Add a new _Spatial_ node as a child of the _Main_ node and name it _Cylinders_. We'll use it to group the cylinders. As a child of it, add a _MeshInstance_ node.

![image4||200](https://docs.godotengine.org/en/stable/_images/05.cylinders_node.png)

In the _Inspector_, assign a _CylinderMesh_ to the _Mesh_ property.

![image5||200](https://docs.godotengine.org/en/stable/_images/06.cylinder_mesh.png)

Set the top viewport to the top orthogonal view using the menu in the viewport's top-left corner. Alternatively, you can press the keypad's 7 key.

![image6||260](https://docs.godotengine.org/en/stable/_images/07.top_view.png)

The grid is a bit distracting for me. You can toggle it by going to the _View_ menu in the toolbar and clicking _View Grid_.

![image7||200](https://docs.godotengine.org/en/stable/_images/08.toggle_view_grid.png)

You now want to move the cylinder along the ground plane, looking at the camera preview in the bottom viewport. I recommend using grid snap to do so. You can toggle it by clicking the magnet icon in the toolbar or pressing Y.

![image8||240](https://docs.godotengine.org/en/stable/_images/09.toggle_grid_snap.png)

Place the cylinder so it's right outside the camera's view in the top-left corner.

![image9||500](https://docs.godotengine.org/en/stable/_images/10.place_first_cylinder.png)

We're going to create copies of the mesh and place them around the game area. Press Ctrl + D (Cmd + D on macOS) to duplicate the node. You can also right-click the node in the _Scene_ dock and select _Duplicate_. Move the copy down along the blue Z axis until it's right outside the camera's preview.

Select both cylinders by pressing the Shift key and clicking on the unselected one and duplicate them.

![image10||500](https://docs.godotengine.org/en/stable/_images/11.both_cylinders_selected.png)

Move them to the right by dragging the red X axis.

![image11||500](https://docs.godotengine.org/en/stable/_images/12.four_cylinders.png)

They're a bit hard to see in white, aren't they? Let's make them stand out by giving them a new material.

In 3D, materials define a surface's visual properties like its color, how it reflects light, and more. We can use them to change the color of a mesh.

We can update all four cylinders at once. Select all the mesh instances in the _Scene_ dock. To do so, you can click on the first one and Shift click on the last one.

![image12||200](https://docs.godotengine.org/en/stable/_images/13.selecting_all_cylinders.png)

In the _Inspector_, expand the _Material_ section and assign a _SpatialMaterial_ to slot _0_.

![image13||200](https://docs.godotengine.org/en/stable/_images/14.spatial_material.png)

Click the sphere icon to open the material resource. You get a preview of the material and a long list of sections filled with properties. You can use these to create all sorts of surfaces, from metal to rock or water.

Expand the _Albedo_ section and set the color to something that contrasts with the background, like a bright orange.

![image14||400](https://docs.godotengine.org/en/stable/_images/15.bright-cylinders.png)

We can now use the cylinders as guides. Fold them in the _Scene_ dock by clicking the grey arrow next to them. Moving forward, you can also toggle their visibility by clicking the eye icon next to _Cylinders_.

![image15||170](https://docs.godotengine.org/en/stable/_images/16.cylinders_fold.png)

Add a _Path_ node as a child of _Main_. In the toolbar, four icons appear. Click the _Add Point_ tool, the icon with the green "+" sign.

![image16](https://docs.godotengine.org/en/stable/_images/17.points_options.png)

> [!Note]
> You can hover any icon to see a tooltip describing the tool.

Click in the center of each cylinder to create a point. Then, click the _Close Curve_ icon in the toolbar to close the path. If any point is a bit off, you can click and drag on it to reposition it.

![image17](https://docs.godotengine.org/en/stable/_images/18.close_path.png)

Your path should look like this.

![image18||300](https://docs.godotengine.org/en/stable/_images/19.path_result.png)

To sample random positions on it, we need a _PathFollow_ node. Add a _PathFollow_ as a child of the _Path_. Rename the two nodes to _SpawnPath_ and _SpawnLocation_, respectively. It's more descriptive of what we'll use them for.

![image19||200](https://docs.godotengine.org/en/stable/_images/20.spawn_nodes.png)

With that, we're ready to code the spawn mechanism.

## Spawning monsters randomly

Right-click on the _Main_ node and attach a new script to it.

We first export a variable to the _Inspector_ so that we can assign `Mob.tscn` or any other monster to it.

Then, as we're going to spawn the monsters procedurally, we want to randomize numbers every time we play the game. If we don't do that, the monsters will always spawn following the same sequence.

```gdscript
extends Node

export (PackedScene) var mob_scene

func _ready():
    randomize()
```

We want to spawn mobs at regular time intervals. To do this, we need to go back to the scene and add a timer. Before that, though, we need to assign the `Mob.tscn` file to the `mob_scene` property.

Head back to the 3D screen and select the _Main_ node. Drag `Mob.tscn` from the _FileSystem_ dock to the _Mob Scene_ slot in the _Inspector_.

![image20||200](https://docs.godotengine.org/en/stable/_images/20.mob_scene_property.png)

Add a new _Timer_ node as a child of _Main_. Name it _MobTimer_.

![image21](https://docs.godotengine.org/en/stable/_images/21.mob_timer.png)

In the _Inspector_, set its _Wait Time_ to `0.5` seconds and turn on _Autostart_ so it automatically starts when we run the game.

![image22||250](https://docs.godotengine.org/en/stable/_images/22.mob_timer_properties.png)

Timers emit a `timeout` signal every time they reach the end of their _Wait Time_. By default, they restart automatically, emitting the signal in a cycle. We can connect to this signal from the _Main_ node to spawn monsters every `0.5` seconds.

With the _MobTimer_ still selected, head to the _Node_ dock on the right and double-click the `timeout` signal.

![image23||240](https://docs.godotengine.org/en/stable/_images/23.timeout_signal.png)

Connect it to the _Main_ node.

![image24||350](https://docs.godotengine.org/en/stable/_images/24.connect_timer_to_main.png)

This will take you back to the script, with a new empty `_on_MobTimer_timeout()` function.

Let's code the mob spawning logic. We're going to:

1.  Instantiate the mob scene.
2.  Sample a random position on the spawn path.
3.  Get the player's position.
4.  Call the mob's `initialize()` method, passing it the random position and the player's position.
5.  Add the mob as a child of the _Main_ node.

```gdscript
func _on_MobTimer_timeout():
    # Create a new instance of the Mob scene.
    var mob = mob_scene.instance()

    # Choose a random location on the SpawnPath.
    # We store the reference to the SpawnLocation node.
    var mob_spawn_location = get_node("SpawnPath/SpawnLocation")
    # And give it a random offset.
    mob_spawn_location.unit_offset = randf()

    var player_position = $Player.transform.origin
    mob.initialize(mob_spawn_location.translation, player_position)

    add_child(mob)
```

Above, `randf()` produces a random value between `0` and `1`, which is what the _PathFollow_ node's `unit_offset` expects.

Here is the complete `Main.gd` script so far, for reference.

```gdscript
extends Node

export (PackedScene) var mob_scene

func _ready():
    randomize()

func _on_MobTimer_timeout():
    var mob = mob_scene.instance()

    var mob_spawn_location = get_node("SpawnPath/SpawnLocation")
    mob_spawn_location.unit_offset = randf()
    var player_position = $Player.transform.origin
    mob.initialize(mob_spawn_location.translation, player_position)

    add_child(mob)
```

You can test the scene by pressing F6. You should see the monsters spawn and move in a straight line.

![image25||400](https://docs.godotengine.org/en/stable/_images/25.spawn_result.png)

For now, they bump and slide against one another when their paths cross. We'll address this in the next part.

# Jumping and squashing monsters

In this part, we'll add the ability to jump, to squash the monsters. In the next lesson, we'll make the player die when a monster hits them on the ground.

First, we have to change a few settings related to physics interactions. Enter the world of [physics layers](https://docs.godotengine.org/en/stable/tutorials/physics/physics_introduction.html#doc-physics-introduction-collision-layers-and-masks).

## Controlling physics interactions

Physics bodies have access to two complementary properties: layers and masks. Layers define on which physics layer(s) an object is.

Masks control the layers that a body will listen to and detect. This affects collision detection. When you want two bodies to interact, you need at least one to have a mask corresponding to the other.

If that's confusing, don't worry, we'll see three examples in a second.

The important point is that you can use layers and masks to filter physics interactions, control performance, and remove the need for extra conditions in your code.

By default, all physics bodies and areas are set to both layer and mask `0`. This means they all collide with each other.

Physics layers are represented by numbers, but we can give them names to keep track of what's what.

### Setting layer names

Let's give our physics layers a name. Go to _Project -> Project Settings_.

![image0||270](https://docs.godotengine.org/en/stable/_images/02.project_settings1.png)

In the left menu, navigate down to _Layer Names -> 3D Physics_. You can see a list of layers with a field next to each of them on the right. You can set their names there. Name the first three layers _player_, _enemies_, and _world_, respectively.

![image1||400](https://docs.godotengine.org/en/stable/_images/03.physics_layers.png)

Now, we can assign them to our physics nodes.

### Assigning layers and masks

In the _Main_ scene, select the _Ground_ node. In the _Inspector_, expand the _Collision_ section. There, you can see the node's layers and masks as a grid of buttons.

![image2||300](https://docs.godotengine.org/en/stable/_images/04.default_physics_properties.png)

The ground is part of the world, so we want it to be part of the third layer. Click the lit button to toggle off the first _Layer_ and toggle on the third one. Then, toggle off the _Mask_ by clicking on it.

![image3||300](https://docs.godotengine.org/en/stable/_images/05.toggle_layer_and_mask.png)

As I mentioned above, the _Mask_ property allows a node to listen to interaction with other physics objects, but we don't need it to have collisions. The _Ground_ doesn't need to listen to anything; it's just there to prevent creatures from falling.

Note that you can click the "..." button on the right side of the properties to see a list of named checkboxes.

![image4||200](https://docs.godotengine.org/en/stable/_images/06.named_checkboxes.png)

Next up are the _Player_ and the _Mob_. Open `Player.tscn` by double-clicking the file in the _FileSystem_ dock.

Select the _Player_ node and set its _Collision -> Mask_ to both "enemies" and "world". You can leave the default _Layer_ property as the first layer is the "player" one.

![image5||200](https://docs.godotengine.org/en/stable/_images/07.player_physics_mask.png)

Then, open the _Mob_ scene by double-clicking on `Mob.tscn` and select the _Mob_ node.

Set its _Collision -> Layer_ to "enemies" and unset its _Collision -> Mask_, leaving the mask empty.

![image6||200](https://docs.godotengine.org/en/stable/_images/08.mob_physics_mask.png)

These settings mean the monsters will move through one another. If you want the monsters to collide with and slide against each other, turn on the "enemies" mask.

> [!Note]
> The mobs don't need to mask the "world" layer because they only move on the XZ plane. We don't apply any gravity to them by design.

## Jumping

The jumping mechanic itself requires only two lines of code. Open the _Player_ script. We need a value to control the jump's strength and update `_physics_process()` to code the jump.

After the line that defines `fall_acceleration`, at the top of the script, add the `jump_impulse`.

```gdscript
#...
# Vertical impulse applied to the character upon jumping in meters per second.
export var jump_impulse = 20
```

Inside `_physics_process()`, add the following code before the line where we called `move_and_slide()`.

```gdscript
func _physics_process(delta):
    #...

    # Jumping.
    if is_on_floor() and Input.is_action_just_pressed("jump"):
        velocity.y += jump_impulse

    #...
```

That's all you need to jump!

The `is_on_floor()` method is a tool from the `KinematicBody` class. It returns `true` if the body collided with the floor in this frame. That's why we apply gravity to the _Player_: so we collide with the floor instead of floating over it like the monsters.

If the character is on the floor and the player presses "jump", we instantly give them a lot of vertical speed. In games, you really want controls to be responsive and giving instant speed boosts like these, while unrealistic, feel great.

Notice that the Y axis is positive upwards. That's unlike 2D, where the Y axis is positive downward.

## Squashing monsters

Let's add the squash mechanic next. We're going to make the character bounce over monsters and kill them at the same time.

We need to detect collisions with a monster and to differentiate them from collisions with the floor. To do so, we can use Godot's [group](https://docs.godotengine.org/en/stable/tutorials/scripting/groups.html#doc-groups) tagging feature.

Open the scene `Mob.tscn` again and select the _Mob_ node. Go to the _Node_ dock on the right to see a list of signals. The _Node_ dock has two tabs: _Signals_, which you've already used, and _Groups_, which allows you to assign tags to nodes.

Click on it to reveal a field where you can write a tag name. Enter "mob" in the field and click the _Add_ button.

![image7||200](https://docs.godotengine.org/en/stable/_images/09.groups_tab.png)

An icon appears in the _Scene_ dock to indicate the node is part of at least one group.

![image8||200](https://docs.godotengine.org/en/stable/_images/10.group_scene_icon.png)

We can now use the group from the code to distinguish collisions with monsters from collisions with the floor.

### Coding the squash mechanic

Head back to the _Player_ script to code the squash and bounce.

At the top of the script, we need another property, `bounce_impulse`. When squashing an enemy, we don't necessarily want the character to go as high up as when jumping.

```gdscript
# Vertical impulse applied to the character upon bouncing over a mob in
# meters per second.
export var bounce_impulse = 16
```

Then, at the bottom of `_physics_process()`, add the following loop. With `move_and_slide()`, Godot makes the body move sometimes multiple times in a row to smooth out the character's motion. So we have to loop over all collisions that may have happened.

In every iteration of the loop, we check if we landed on a mob. If so, we kill it and bounce.

With this code, if no collisions occurred on a given frame, the loop won't run.

```gdscript
func _physics_process(delta):
    #...
    for index in range(get_slide_count()):
        # We check every collision that occurred this frame.
        var collision = get_slide_collision(index)
        # If we collide with a monster...
        if collision.collider.is_in_group("mob"):
            var mob = collision.collider
            # ...we check that we are hitting it from above.
            if Vector3.UP.dot(collision.normal) > 0.1:
                # If so, we squash it and bounce.
                mob.squash()
                velocity.y = bounce_impulse
```

That's a lot of new functions. Here's some more information about them.

The functions `get_slide_count()` and `get_slide_collision()` both come from the [KinematicBody](https://docs.godotengine.org/en/stable/classes/class_kinematicbody.html#class-kinematicbody) class and are related to `move_and_slide()`.

`get_slide_collision()` returns a [KinematicCollision](https://docs.godotengine.org/en/stable/classes/class_kinematiccollision.html#class-kinematiccollision) object that holds information about where and how the collision occurred. For example, we use its `collider` property to check if we collided with a "mob" by calling `is_in_group()` on it: `collision.collider.is_in_group("mob")`.

> [!Note]
> The method `is_in_group()` is available on every [Node](https://docs.godotengine.org/en/stable/classes/class_node.html#class-node).

To check that we are landing on the monster, we use the vector dot product: `Vector3.UP.dot(collision.normal) > 0.1`. The collision normal is a 3D vector that is perpendicular to the plane where the collision occurred. The dot product allows us to compare it to the up direction.

With dot products, when the result is greater than `0`, the two vectors are at an angle of fewer than 90 degrees. A value higher than `0.1` tells us that we are roughly above the monster.

We are calling one undefined function, `mob.squash()`. We have to add it to the Mob class.

Open the script `Mob.gd` by double-clicking on it in the _FileSystem_ dock. At the top of the script, we want to define a new signal named `squashed`. And at the bottom, you can add the squash function, where we emit the signal and destroy the mob.

```gdscript
# Emitted when the player jumped on the mob.
signal squashed
# ...

func squash():
    emit_signal("squashed")
    queue_free()
```

We will use the signal to add points to the score in the next lesson.

With that, you should be able to kill monsters by jumping on them. You can press F5 to try the game and set `Main.tscn` as your project's main scene.

However, the player won't die yet. We'll work on that in the next part.

# Killing the player

We can kill enemies by jumping on them, but the player still can't die. Let's fix this.

We want to detect being hit by an enemy differently from squashing them. We want the player to die when they're moving on the floor, but not if they're in the air. We could use vector math to distinguish the two kinds of collisions. Instead, though, we will use an _Area_ node, which works well for hitboxes.

## Hitbox with the Area node

Head back to the _Player_ scene and add a new _Area_ node. Name it _MobDetector_. Add a _CollisionShape_ node as a child of it.

![image0||200](https://docs.godotengine.org/en/stable/_images/01.adding_area_node.png)

In the _Inspector_, assign a cylinder shape to it.

![image1||200](https://docs.godotengine.org/en/stable/_images/02.cylinder_shape.png)

Here is a trick you can use to make the collisions only happen when the player is on the ground or close to it. You can reduce the cylinder's height and move it up to the top of the character. This way, when the player jumps, the shape will be too high up for the enemies to collide with it.

![image2||300](https://docs.godotengine.org/en/stable/_images/03.cylinder_in_editor.png)

You also want the cylinder to be wider than the sphere. This way, the player gets hit before colliding and being pushed on top of the monster's collision box.

The wider the cylinder, the more easily the player will get killed.

Next, select the _MobDetector_ node again, and in the _Inspector_, turn off its _Monitorable_ property. This makes it so other physics nodes cannot detect the area. The complementary _Monitoring_ property allows it to detect collisions. Then, remove the _Collision -> Layer_ and set the mask to the "enemies" layer.

![image3||200](https://docs.godotengine.org/en/stable/_images/04.mob_detector_properties.png)

When areas detect a collision, they emit signals. We're going to connect one to the _Player_ node. In the _Node_ tab, double-click the `body_entered` signal and connect it to the _Player_.

![image4||200](https://docs.godotengine.org/en/stable/_images/05.body_entered_signal.png)

The _MobDetector_ will emit `body_entered` when a _KinematicBody_ or a _RigidBody_ node enters it. As it only masks the "enemies" physics layers, it will only detect the _Mob_ nodes.

Code-wise, we're going to do two things: emit a signal we'll later use to end the game and destroy the player. We can wrap these operations in a `die()` function that helps us put a descriptive label on the code.

```gdscript
# Emitted when the player was hit by a mob.
# Put this at the top of the script.
signal hit

# And this function at the bottom.
func die():
    emit_signal("hit")
    queue_free()

func _on_MobDetector_body_entered(_body):
    die()
```

Try the game again by pressing F5. If everything is set up correctly, the character should die when an enemy runs into it.

However, note that this depends entirely on the size and position of the _Player_ and the _Mob_'s collision shapes. You may need to move them and resize them to achieve a tight game feel.

## Ending the game

We can use the _Player_'s `hit` signal to end the game. All we need to do is connect it to the _Main_ node and stop the _MobTimer_ in reaction.

Open `Main.tscn`, select the _Player_ node, and in the _Node_ dock, connect its `hit` signal to the _Main_ node.

![image5||200](https://docs.godotengine.org/en/stable/_images/06.player_hit_signal.png)

Get and stop the timer in the `_on_Player_hit()` function.

```gdscript
func _on_Player_hit():
    $MobTimer.stop()
```

If you try the game now, the monsters will stop spawning when you die, and the remaining ones will leave the screen.

You can pat yourself in the back: you prototyped a complete 3D game, even if it's still a bit rough.

From there, we'll add a score, the option to retry the game, and you'll see how you can make the game feel much more alive with minimalistic animations.

## Code checkpoint

Here are the complete scripts for the _Main_, _Mob_, and _Player_ nodes, for reference. You can use them to compare and check your code.

Starting with `Main.gd`.

```gdscript
extends Node

export(PackedScene) var mob_scene

func _ready():
    randomize()

func _on_MobTimer_timeout():
    # Create a new instance of the Mob scene.
    var mob = mob_scene.instance()

    # Choose a random location on the SpawnPath.
    var mob_spawn_location = get_node("SpawnPath/SpawnLocation")
    # And give it a random offset.
    mob_spawn_location.unit_offset = randf()

    # Communicate the spawn location and the player's location to the mob.
    var player_position = $Player.transform.origin
    mob.initialize(mob_spawn_location.translation, player_position)

    # Spawn the mob by adding it to the Main scene.
    add_child(mob)

func _on_Player_hit():
    $MobTimer.stop()
```

Next is `Mob.gd`.

```gdscript
extends KinematicBody

# Emitted when the player jumped on the mob.
signal squashed

# Minimum speed of the mob in meters per second.
export var min_speed = 10
# Maximum speed of the mob in meters per second.
export var max_speed = 18

var velocity = Vector3.ZERO

func _physics_process(_delta):
    move_and_slide(velocity)

func initialize(start_position, player_position):
    look_at_from_position(start_position, player_position, Vector3.UP)
    rotate_y(rand_range(-PI / 4, PI / 4))

    var random_speed = rand_range(min_speed, max_speed)
    velocity = Vector3.FORWARD * random_speed
    velocity = velocity.rotated(Vector3.UP, rotation.y)

 func squash():
    emit_signal("squashed")
    queue_free()

func _on_VisibilityNotifier_screen_exited():
    queue_free()
```

Finally, the longest script, `Player.gd`.

```gdscript
extends KinematicBody

# Emitted when a mob hit the player.
signal hit

# How fast the player moves in meters per second.
export var speed = 14
# The downward acceleration when in the air, in meters per second squared.
export var fall_acceleration = 75
# Vertical impulse applied to the character upon jumping in meters per second.
export var jump_impulse = 20
# Vertical impulse applied to the character upon bouncing over a mob in meters per second.
export var bounce_impulse = 16

var velocity = Vector3.ZERO

func _physics_process(delta):
    var direction = Vector3.ZERO

    if Input.is_action_pressed("move_right"):
        direction.x += 1
    if Input.is_action_pressed("move_left"):
        direction.x -= 1
    if Input.is_action_pressed("move_back"):
        direction.z += 1
    if Input.is_action_pressed("move_forward"):
        direction.z -= 1

    if direction != Vector3.ZERO:
        direction = direction.normalized()
        $Pivot.look_at(translation + direction, Vector3.UP)

    velocity.x = direction.x * speed
    velocity.z = direction.z * speed

    # Jumping.
    if is_on_floor() and Input.is_action_just_pressed("jump"):
        velocity.y += jump_impulse

    velocity.y -= fall_acceleration * delta
    velocity = move_and_slide(velocity, Vector3.UP)

    for index in range(get_slide_count()):
        var collision = get_slide_collision(index)
        if collision.collider.is_in_group("mob"):
            var mob = collision.collider
            if Vector3.UP.dot(collision.normal) > 0.1:
                mob.squash()
                velocity.y = bounce_impulse

func die():
    emit_signal("hit")
    queue_free()

func _on_MobDetector_body_entered(_body):
    die()
```

See you in the next lesson to add the score and the retry option.

# Score and replay

In this part, we'll add the score, music playback, and the ability to restart the game.

We have to keep track of the current score in a variable and display it on screen using a minimal interface. We will use a text label to do that.

In the main scene, add a new _Control_ node as a child of _Main_ and name it _UserInterface_. You will automatically be taken to the 2D screen, where you can edit your User Interface (UI).

Add a _Label_ node and rename it to _ScoreLabel_.

![image0||200](https://docs.godotengine.org/en/stable/_images/01.label_node.png)

In the _Inspector_, set the _Label_'s _Text_ to a placeholder like "Score: 0".

![image1||200](https://docs.godotengine.org/en/stable/_images/02.score_placeholder.png)

Also, the text is white by default, like our game's background. We need to change its color to see it at runtime.

Scroll down to _Theme Overrides_, and expand _Colors_ and click the black box next to _Font Color_ to tint the text.

![image2||200](https://docs.godotengine.org/en/stable/_images/02.score_custom_color.png)

Pick a dark tone so it contrasts well with the 3D scene.

![image3||170](https://docs.godotengine.org/en/stable/_images/02.score_color_picker.png)

Finally, click and drag on the text in the viewport to move it away from the top-left corner.

![image4||170](https://docs.godotengine.org/en/stable/_images/02.score_label_moved.png)

The _UserInterface_ node allows us to group our UI in a branch of the scene tree and use a theme resource that will propagate to all its children. We'll use it to set our game's font.

## Creating a UI theme

Once again, select the _UserInterface_ node. In the _Inspector_, create a new theme resource in _Theme -> Theme_.

![image5||200](https://docs.godotengine.org/en/stable/_images/03.creating_theme.png)

Click on it to open the theme editor In the bottom panel. It gives you a preview of how all the built-in UI widgets will look with your theme resource.

![image6||400](https://docs.godotengine.org/en/stable/_images/04.theme_preview.png)

By default, a theme only has one property, the _Default Font_.

> [!info]
> You can add more properties to the theme resource to design complex user interfaces, but that is beyond the scope of this series. To learn more about creating and editing themes, see [Introduction to GUI skinning](https://docs.godotengine.org/en/stable/tutorials/ui/gui_skinning.html#doc-gui-skinning).

Click the _Default Font_ property and create a new _DynamicFont_.

![image7||200](https://docs.godotengine.org/en/stable/_images/05.dynamic_font.png)

Expand the _DynamicFont_ by clicking on it and expand its _Font_ section. There, you will see an empty _Font Data_ field.

![image8||200](https://docs.godotengine.org/en/stable/_images/06.font_data.png)

This one expects a font file like the ones you have on your computer. DynamicFont supports the following formats:

-   TrueType (`.ttf`)
-   OpenType (`.otf`)
-   Web Open Font Format 1 (`.woff`)
-   Web Open Font Format 2 (`.woff2`, since Godot 3.5)

In the _FileSystem_ dock, expand the `fonts` directory and click and drag the `Montserrat-Medium.ttf` file we included in the project onto the _Font Data_. The text will reappear in the theme preview.

The text is a bit small. Set the _Settings -> Size_ to `22` pixels to increase the text's size.

![image9||200](https://docs.godotengine.org/en/stable/_images/07.font_size.png)

## Keeping track of the score

Let's work on the score next. Attach a new script to the _ScoreLabel_ and define the `score` variable.

```gdscript
extends Label

var score = 0
```

The score should increase by `1` every time we squash a monster. We can use their `squashed` signal to know when that happens. However, as we instantiate monsters from the code, we cannot do the connection in the editor.

Instead, we have to make the connection from the code every time we spawn a monster.

Open the script `Main.gd`. If it's still open, you can click on its name in the script editor's left column.

![image10||200](https://docs.godotengine.org/en/stable/_images/08.open_main_script.png)

Alternatively, you can double-click the `Main.gd` file in the _FileSystem_ dock.

At the bottom of the `_on_MobTimer_timeout()` function, add the following line.

```gdscript
func _on_MobTimer_timeout():
    #...
    # We connect the mob to the score label to update the score upon squashing one.
    mob.connect("squashed", $UserInterface/ScoreLabel, "_on_Mob_squashed")
```

This line means that when the mob emits the `squashed` signal, the _ScoreLabel_ node will receive it and call the function `_on_Mob_squashed()`.

Head back to the `ScoreLabel.gd` script to define the `_on_Mob_squashed()` callback function.

There, we increment the score and update the displayed text.

```gdscript
func _on_Mob_squashed():
    score += 1
    text = "Score: %s" % score
```

The second line uses the value of the `score` variable to replace the placeholder `%s`. When using this feature, Godot automatically converts values to text, which is convenient to output text in labels or using the `print()` function.

> [!info]
> You can learn more about string formatting here: [GDScript format strings](https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_format_string.html#doc-gdscript-printf).

You can now play the game and squash a few enemies to see the score increase.

![image11||300](https://docs.godotengine.org/en/stable/_images/09.score_in_game.png)

> [!Note]
> In a complex game, you may want to completely separate your user interface from the game world. In that case, you would not keep track of the score on the label. Instead, you may want to store it in a separate, dedicated object. But when prototyping or when your project is simple, it is fine to keep your code simple. Programming is always a balancing act.

## Retrying the game

We'll now add the ability to play again after dying. When the player dies, we'll display a message on the screen and wait for input.

Head back to the _Main_ scene, select the _UserInterface_ node, add a _ColorRect_ node as a child of it and name it _Retry_. This node fills a rectangle with a uniform color and will serve as an overlay to darken the screen.

To make it span over the whole viewport, you can use the _Layout_ menu in the toolbar.

![image12||200](https://docs.godotengine.org/en/stable/_images/10.layout_icon.png)

Open it and apply the _Full Rect_ command.

![image13||100](https://docs.godotengine.org/en/stable/_images/11.full_rect_option.png)

Nothing happens. Well, almost nothing: only the four green pins move to the corners of the selection box.

![image14||100](https://docs.godotengine.org/en/stable/_images/12.anchors_updated.png)

This is because UI nodes (all the ones with a green icon) work with anchors and margins relative to their parent's bounding box. Here, the _UserInterface_ node has a small size and the _Retry_ one is limited by it.

Select the _UserInterface_ and apply _Layout -> Full Rect_ to it as well. The _Retry_ node should now span the whole viewport.

Let's change its color so it darkens the game area. Select _Retry_ and in the _Inspector_, set its _Color_ to something both dark and transparent. To do so, in the color picker, drag the _A_ slider to the left. It controls the color's alpha channel, that is to say, its opacity.

![image15||170](https://docs.godotengine.org/en/stable/_images/13.retry_color_picker.png)

Next, add a _Label_ as a child of _Retry_ and give it the _Text_ "Press Enter to retry."

![image16||170](https://docs.godotengine.org/en/stable/_images/14.retry_node.png)

To move it and anchor it in the center of the screen, apply _Layout -> Center_ to it.

![image17||100](https://docs.godotengine.org/en/stable/_images/15.layout_center.png)

### Coding the retry option

We can now head to the code to show and hide the _Retry_ node when the player dies and plays again.

Open the script `Main.gd`. First, we want to hide the overlay at the start of the game. Add this line to the `_ready()` function.

```gdscript
func _ready():
    #...
    $UserInterface/Retry.hide()
```

Then, when the player gets hit, we show the overlay.

```gdscript
func _on_Player_hit():
    #...
    $UserInterface/Retry.show()
```

Finally, when the _Retry_ node is visible, we need to listen to the player's input and restart the game if they press enter. To do this, we use the built-in `_unhandled_input()` callback.

If the player pressed the predefined `ui_accept` input action and _Retry_ is visible, we reload the current scene.

```gdscript
func _unhandled_input(event):
    if event.is_action_pressed("ui_accept") and $UserInterface/Retry.visible:
        # This restarts the current scene.
        get_tree().reload_current_scene()
```

The function `get_tree()` gives us access to the global [SceneTree](https://docs.godotengine.org/en/stable/classes/class_scenetree.html#class-scenetree) object, which allows us to reload and restart the current scene.

## Adding music

To add music that plays continuously in the background, we're going to use another feature in Godot: [autoloads](https://docs.godotengine.org/en/stable/tutorials/scripting/singletons_autoload.html#doc-singletons-autoload).

To play audio, all you need to do is add an _AudioStreamPlayer_ node to your scene and attach an audio file to it. When you start the scene, it can play automatically. However, when you reload the scene, like we do to play again, the audio nodes are also reset, and the music starts back from the beginning.

You can use the autoload feature to have Godot load a node or a scene automatically at the start of the game, outside the current scene. You can also use it to create globally accessible objects.

Create a new scene by going to the _Scene_ menu and clicking _New Scene_.

![image18||270](https://docs.godotengine.org/en/stable/_images/16.new_scene.png)

Click the _Other Node_ button to create an _AudioStreamPlayer_ and rename it to _MusicPlayer_.

![image19||180](https://docs.godotengine.org/en/stable/_images/17.music_player_node.png)

We included a music soundtrack in the `art/` directory, `House In a Forest Loop.ogg`. Click and drag it onto the _Stream_ property in the _Inspector_. Also, turn on _Autoplay_ so the music plays automatically at the start of the game.

![image20||180](https://docs.godotengine.org/en/stable/_images/18.music_node_properties.png)

Save the scene as `MusicPlayer.tscn`.

We have to register it as an autoload. Head to the _Project -> Project Settings…_ menu and click on the _Autoload_ tab.

In the _Path_ field, you want to enter the path to your scene. Click the folder icon to open the file browser and double-click on `MusicPlayer.tscn`. Then, click the _Add_ button on the right to register the node.

![image21||400](https://docs.godotengine.org/en/stable/_images/19.register_autoload.png)

If you run the game now, the music will play automatically. And even when you lose and retry, it keeps going.

Before we wrap up this lesson, here's a quick look at how it works under the hood. When you run the game, your _Scene_ dock changes to give you two tabs: _Remote_ and _Local_.

![image22||200](https://docs.godotengine.org/en/stable/_images/20.scene_dock_tabs.png)

The _Remote_ tab allows you to visualize the node tree of your running game. There, you will see the _Main_ node and everything the scene contains and the instantiated mobs at the bottom.

![image23||200](https://docs.godotengine.org/en/stable/_images/21.remote_scene_tree.png)

At the top are the autoloaded _MusicPlayer_ and a _root_ node, which is your game's viewport.

And that does it for this lesson. In the next part, we'll add an animation to make the game both look and feel much nicer.

Here is the complete `Main.gd` script for reference.

```gdscript
extends Node

export (PackedScene) var mob_scene

func _ready():
    randomize()
    $UserInterface/Retry.hide()

func _unhandled_input(event):
    if event.is_action_pressed("ui_accept") and $UserInterface/Retry.visible:
        get_tree().reload_current_scene()

func _on_MobTimer_timeout():
    var mob = mob_scene.instance()

    var mob_spawn_location = get_node("SpawnPath/SpawnLocation")
    mob_spawn_location.unit_offset = randf()

    var player_position = $Player.transform.origin
    mob.initialize(mob_spawn_location.translation, player_position)

    add_child(mob)
    mob.connect("squashed", $UserInterface/ScoreLabel, "_on_Mob_squashed")

func _on_Player_hit():
    $MobTimer.stop()
    $UserInterface/Retry.show()
```

# Character animation

In this final lesson, we'll use Godot's built-in animation tools to make our characters float and flap. You'll learn to design animations in the editor and use code to make your game feel alive.

![image0||300](https://docs.godotengine.org/en/stable/_images/squash-the-creeps-final.gif)

We'll start with an introduction to using the animation editor.

## Using the animation editor

The engine comes with tools to author animations in the editor. You can then use the code to play and control them at runtime.

Open the player scene, select the player node, and add an _AnimationPlayer_ node.

The _Animation_ dock appears in the bottom panel.

![image1||400](https://docs.godotengine.org/en/stable/_images/01.animation_player_dock.png)

It features a toolbar and the animation drop-down menu at the top, a track editor in the middle that's currently empty, and filter, snap, and zoom options at the bottom.

Let's create an animation. Click on _Animation -> New_.

![image2](https://docs.godotengine.org/en/stable/_images/02.new_animation.png)

Name the animation "float".

![image3](https://docs.godotengine.org/en/stable/_images/03.float_name.png)

Once you created the animation, the timeline appears with numbers representing time in seconds.

![image4](https://docs.godotengine.org/en/stable/_images/03.timeline.png)

We want the animation to start playback automatically at the start of the game. Also, it should loop.

To do so, you can click the button with an "A+" icon in the animation toolbar and the looping arrows, respectively.

![image5](https://docs.godotengine.org/en/stable/_images/04.autoplay_and_loop.png)

You can also pin the animation editor by clicking the pin icon in the top-right. This prevents it from folding when you click on the viewport and deselect the nodes.

![image6](https://docs.godotengine.org/en/stable/_images/05.pin_icon.png)

Set the animation duration to `1.2` seconds in the top-right of the dock.

![image7](https://docs.godotengine.org/en/stable/_images/06.animation_duration.png)

You should see the gray ribbon widen a bit. It shows you the start and end of your animation and the vertical blue line is your time cursor.

![image8](https://docs.godotengine.org/en/stable/_images/07.editable_timeline.png)

You can click and drag the slider in the bottom-right to zoom in and out of the timeline.

![image9](https://docs.godotengine.org/en/stable/_images/08.zoom_slider.png)

## The float animation[¶](https://docs.godotengine.org/en/stable/getting_started/first_3d_game/09.adding_animations.html#the-float-animation "Permalink to this headline")

With the animation player node, you can animate most properties on as many nodes as you need. Notice the key icon next to properties in the _Inspector_. You can click any of them to create a keyframe, a time and value pair for the corresponding property. The keyframe gets inserted where your time cursor is in the timeline.

Let's insert our first keys. Here, we will animate both the translation and the rotation of the _Character_ node.

Select the _Character_ and click the key icon next to _Translation_ in the _Inspector_. Do the same for _Rotation Degrees_.

![image10](https://docs.godotengine.org/en/stable/_images/09.creating_first_keyframe.png)

Two tracks appear in the editor with a diamond icon representing each keyframe.

![image11](https://docs.godotengine.org/en/stable/_images/10.initial_keys.png)

You can click and drag on the diamonds to move them in time. Move the translation key to `0.2` seconds and the rotation key to `0.1` seconds.

![image12](https://docs.godotengine.org/en/stable/_images/11.moving_keys.png)

Move the time cursor to `0.5` seconds by clicking and dragging on the gray timeline. In the _Inspector_, set the _Translation_'s _Y_ axis to about `0.65` meters and the _Rotation Degrees_' _X_ axis to `8`.

![image13](https://docs.godotengine.org/en/stable/_images/12.second_keys_values.png)

Create a keyframe for both properties and shift the translation key to `0.7` seconds by dragging it on the timeline.

![image14](https://docs.godotengine.org/en/stable/_images/13.second_keys.png)

Note

A lecture on the principles of animation is beyond the scope of this tutorial. Just note that you don't want to time and space everything evenly. Instead, animators play with timing and spacing, two core animation principles. You want to offset and contrast in your character's motion to make them feel alive.

Move the time cursor to the end of the animation, at `1.2` seconds. Set the Y translation to about `0.35` and the X rotation to `-9` degrees. Once again, create a key for both properties.

You can preview the result by clicking the play button or pressing Shift + D. Click the stop button or press S to stop playback.

![image15](https://docs.godotengine.org/en/stable/_images/14.play_button.png)

You can see that the engine interpolates between your keyframes to produce a continuous animation. At the moment, though, the motion feels very robotic. This is because the default interpolation is linear, causing constant transitions, unlike how living things move in the real world.

We can control the transition between keyframes using easing curves.

Click and drag around the first two keys in the timeline to box select them.

![image16](https://docs.godotengine.org/en/stable/_images/15.box_select.png)

You can edit the properties of both keys simultaneously in the _Inspector_, where you can see an _Easing_ property.

![image17](https://docs.godotengine.org/en/stable/_images/16.easing_property.png)

Click and drag on the curve, pulling it towards the left. This will make it ease-out, that is to say, transition fast initially and slow down as the time cursor reaches the next keyframe.

![image18](https://docs.godotengine.org/en/stable/_images/17.ease_out.png)

Play the animation again to see the difference. The first half should already feel a bit bouncier.

Apply an ease-out to the second keyframe in the rotation track.

![image19](https://docs.godotengine.org/en/stable/_images/18.ease_out_second_rotation_key.png)

Do the opposite for the second translation keyframe, dragging it to the right.

![image20](https://docs.godotengine.org/en/stable/_images/19.ease_in_second_translation_key.png)

Your animation should look something like this.

![image21](https://docs.godotengine.org/en/stable/_images/20.float_animation.gif)

Note

Animations update the properties of the animated nodes every frame, overriding initial values. If we directly animated the _Player_ node, it would prevent us from moving it in code. This is where the _Pivot_ node comes in handy: even though we animated the _Character_, we can still move and rotate the _Pivot_ and layer changes on top of the animation in a script.

If you play the game, the player's creature will now float!

If the creature is a little too close to the floor, you can move the _Pivot_ up to offset it.

### Controlling the animation in code[¶](https://docs.godotengine.org/en/stable/getting_started/first_3d_game/09.adding_animations.html#controlling-the-animation-in-code "Permalink to this headline")

We can use code to control the animation playback based on the player's input. Let's change the animation speed when the character is moving.

Open the _Player_'s script by clicking the script icon next to it.

![image22](https://docs.godotengine.org/en/stable/_images/21.script_icon.png)

In `_physics_process()`, after the line where we check the `direction` vector, add the following code.

GDScriptC#

func _physics_process(delta):
    #...
    #if direction != Vector3.ZERO:
        #...
        $AnimationPlayer.playback_speed = 4
    else:
        $AnimationPlayer.playback_speed = 1

This code makes it so when the player moves, we multiply the playback speed by `4`. When they stop, we reset it to normal.

We mentioned that the pivot could layer transforms on top of the animation. We can make the character arc when jumping using the following line of code. Add it at the end of `_physics_process()`.

GDScriptC#

func _physics_process(delta):
    #...
    $Pivot.rotation.x = PI / 6 * velocity.y / jump_impulse

## Animating the mobs[¶](https://docs.godotengine.org/en/stable/getting_started/first_3d_game/09.adding_animations.html#animating-the-mobs "Permalink to this headline")

Here's another nice trick with animations in Godot: as long as you use a similar node structure, you can copy them to different scenes.

For example, both the _Mob_ and the _Player_ scenes have a _Pivot_ and a _Character_ node, so we can reuse animations between them.

Open the _Player_ scene, select the animation player node and open the "float" animation. Next, click on **Animation > Copy**. Then open `Mob.tscn` and open its animation player. Click **Animation > Paste**. That's it; all monsters will now play the float animation.

We can change the playback speed based on the creature's `random_speed`. Open the _Mob_'s script and at the end of the `initialize()` function, add the following line.

GDScriptC#

func initialize(start_position, player_position):
    #...
    $AnimationPlayer.playback_speed = random_speed / min_speed

And with that, you finished coding your first complete 3D game.

**Congratulations**!

In the next part, we'll quickly recap what you learned and give you some links to keep learning more. But for now, here are the complete `Player.gd` and `Mob.gd` so you can check your code against them.

Here's the _Player_ script.

GDScriptC#

extends KinematicBody

# Emitted when the player was hit by a mob.
signal hit

# How fast the player moves in meters per second.
export var speed = 14
# The downward acceleration when in the air, in meters per second per second.
export var fall_acceleration = 75
# Vertical impulse applied to the character upon jumping in meters per second.
export var jump_impulse = 20
# Vertical impulse applied to the character upon bouncing over a mob in meters per second.
export var bounce_impulse = 16

var velocity = Vector3.ZERO

func _physics_process(delta):
    var direction = Vector3.ZERO

    if Input.is_action_pressed("move_right"):
        direction.x += 1
    if Input.is_action_pressed("move_left"):
        direction.x -= 1
    if Input.is_action_pressed("move_back"):
        direction.z += 1
    if Input.is_action_pressed("move_forward"):
        direction.z -= 1

    if direction != Vector3.ZERO:
        direction = direction.normalized()
        $Pivot.look_at(translation + direction, Vector3.UP)
        $AnimationPlayer.playback_speed = 4
    else:
        $AnimationPlayer.playback_speed = 1

    velocity.x = direction.x * speed
    velocity.z = direction.z * speed

    # Jumping
    if is_on_floor() and Input.is_action_just_pressed("jump"):
        velocity.y += jump_impulse

    velocity.y -= fall_acceleration * delta
    velocity = move_and_slide(velocity, Vector3.UP)

    for index in range(get_slide_count()):
        var collision = get_slide_collision(index)
        if collision.collider.is_in_group("mob"):
            var mob = collision.collider
            if Vector3.UP.dot(collision.normal) > 0.1:
                mob.squash()
                velocity.y = bounce_impulse

    $Pivot.rotation.x = PI / 6 * velocity.y / jump_impulse

func die():
    emit_signal("hit")
    queue_free()

func _on_MobDetector_body_entered(_body):
    die()

And the _Mob_'s script.

GDScriptC#

extends KinematicBody

# Emitted when the player jumped on the mob.
signal squashed

# Minimum speed of the mob in meters per second.
export var min_speed = 10
# Maximum speed of the mob in meters per second.
export var max_speed = 18

var velocity = Vector3.ZERO

func _physics_process(_delta):
    move_and_slide(velocity)

func initialize(start_position, player_position):
    look_at_from_position(start_position, player_position, Vector3.UP)
    rotate_y(rand_range(-PI / 4, PI / 4))

    var random_speed = rand_range(min_speed, max_speed)
    velocity = Vector3.FORWARD * random_speed
    velocity = velocity.rotated(Vector3.UP, rotation.y)

    $AnimationPlayer.playback_speed = random_speed / min_speed

 func squash():
    emit_signal("squashed")
    queue_free()

func _on_VisibilityNotifier_screen_exited():
    queue_free()